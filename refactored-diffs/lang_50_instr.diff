diff --git a/src/java/org/apache/commons/lang/enum/Enum.java b/src/java/org/apache/commons/lang/enum/Enum.java
deleted file mode 100644
index 66ebab55..00000000
--- a/src/java/org/apache/commons/lang/enum/Enum.java
+++ /dev/null
@@ -1,643 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.io.Serializable;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.WeakHashMap;
-
-import org.apache.commons.lang.ClassUtils;
-import org.apache.commons.lang.StringUtils;
-
-/**
- * <p>Abstract superclass for type-safe enums.</p>
- *
- * <p>One feature of the C programming language lacking in Java is enumerations. The
- * C implementation based on ints was poor and open to abuse. The original Java
- * recommendation and most of the JDK also uses int constants. It has been recognised
- * however that a more robust type-safe class-based solution can be designed. This
- * class follows the basic Java type-safe enumeration pattern.</p>
- *
- * <p><em>NOTE:</em>Due to the way in which Java ClassLoaders work, comparing
- * Enum objects should always be done using <code>equals()</code>, not <code>==</code>.
- * The equals() method will try == first so in most cases the effect is the same.</p>
- * 
- * <p>Of course, if you actually want (or don't mind) Enums in different class
- * loaders being non-equal, then you can use <code>==</code>.</p>
- * 
- * <h4>Simple Enums</h4>
- *
- * <p>To use this class, it must be subclassed. For example:</p>
- *
- * <pre>
- * public final class ColorEnum extends Enum {
- *   public static final ColorEnum RED = new ColorEnum("Red");
- *   public static final ColorEnum GREEN = new ColorEnum("Green");
- *   public static final ColorEnum BLUE = new ColorEnum("Blue");
- *
- *   private ColorEnum(String color) {
- *     super(color);
- *   }
- * 
- *   public static ColorEnum getEnum(String color) {
- *     return (ColorEnum) getEnum(ColorEnum.class, color);
- *   }
- * 
- *   public static Map getEnumMap() {
- *     return getEnumMap(ColorEnum.class);
- *   }
- * 
- *   public static List getEnumList() {
- *     return getEnumList(ColorEnum.class);
- *   }
- * 
- *   public static Iterator iterator() {
- *     return iterator(ColorEnum.class);
- *   }
- * }
- * </pre>
- *
- * <p>As shown, each enum has a name. This can be accessed using <code>getName</code>.</p>
- *
- * <p>The <code>getEnum</code> and <code>iterator</code> methods are recommended.
- * Unfortunately, Java restrictions require these to be coded as shown in each subclass.
- * An alternative choice is to use the {@link EnumUtils} class.</p>
- * 
- * <h4>Subclassed Enums</h4>
- * <p>A hierarchy of Enum classes can be built. In this case, the superclass is
- * unaffected by the addition of subclasses (as per normal Java). The subclasses
- * may add additional Enum constants <em>of the type of the superclass</em>. The
- * query methods on the subclass will return all of the Enum constants from the
- * superclass and subclass.</p>
- *
- * <pre>
- * public final class ExtraColorEnum extends ColorEnum {
- *   // NOTE: Color enum declared above is final, change that to get this
- *   // example to compile.
- *   public static final ColorEnum YELLOW = new ExtraColorEnum("Yellow");
- *
- *   private ExtraColorEnum(String color) {
- *     super(color);
- *   }
- * 
- *   public static ColorEnum getEnum(String color) {
- *     return (ColorEnum) getEnum(ExtraColorEnum.class, color);
- *   }
- * 
- *   public static Map getEnumMap() {
- *     return getEnumMap(ExtraColorEnum.class);
- *   }
- * 
- *   public static List getEnumList() {
- *     return getEnumList(ExtraColorEnum.class);
- *   }
- * 
- *   public static Iterator iterator() {
- *     return iterator(ExtraColorEnum.class);
- *   }
- * }
- * </pre>
- *
- * <p>This example will return RED, GREEN, BLUE, YELLOW from the List and iterator
- * methods in that order. The RED, GREEN and BLUE instances will be the same (==) 
- * as those from the superclass ColorEnum. Note that YELLOW is declared as a
- * ColorEnum and not an ExtraColorEnum.</p>
- * 
- * <h4>Functional Enums</h4>
- *
- * <p>The enums can have functionality by defining subclasses and
- * overriding the <code>getEnumClass()</code> method:</p>
- * 
- * <pre>
- *   public static final OperationEnum PLUS = new PlusOperation();
- *   private static final class PlusOperation extends OperationEnum {
- *     private PlusOperation() {
- *       super("Plus");
- *     }
- *     public int eval(int a, int b) {
- *       return a + b;
- *     }
- *   }
- *   public static final OperationEnum MINUS = new MinusOperation();
- *   private static final class MinusOperation extends OperationEnum {
- *     private MinusOperation() {
- *       super("Minus");
- *     }
- *     public int eval(int a, int b) {
- *       return a - b;
- *     }
- *   }
- *
- *   private OperationEnum(String color) {
- *     super(color);
- *   }
- * 
- *   public final Class getEnumClass() {     // NOTE: new method!
- *     return OperationEnum.class;
- *   }
- *
- *   public abstract double eval(double a, double b);
- * 
- *   public static OperationEnum getEnum(String name) {
- *     return (OperationEnum) getEnum(OperationEnum.class, name);
- *   }
- * 
- *   public static Map getEnumMap() {
- *     return getEnumMap(OperationEnum.class);
- *   }
- * 
- *   public static List getEnumList() {
- *     return getEnumList(OperationEnum.class);
- *   }
- * 
- *   public static Iterator iterator() {
- *     return iterator(OperationEnum.class);
- *   }
- * }
- * </pre>
- * <p>The code above will work on JDK 1.2. If JDK1.3 and later is used,
- * the subclasses may be defined as anonymous.</p>
- * 
- * <h4>Nested class Enums</h4>
- *
- * <p>Care must be taken with class loading when defining a static nested class
- * for enums. The static nested class can be loaded without the surrounding outer
- * class being loaded. This can result in an empty list/map/iterator being returned.
- * One solution is to define a static block that references the outer class where
- * the constants are defined. For example:</p>
- *
- * <pre>
- * public final class Outer {
- *   public static final BWEnum BLACK = new BWEnum("Black");
- *   public static final BWEnum WHITE = new BWEnum("White");
- *
- *   // static nested enum class
- *   public static final class BWEnum extends Enum {
- * 
- *     static {
- *       // explicitly reference BWEnum class to force constants to load
- *       Object obj = Outer.BLACK;
- *     }
- * 
- *     // ... other methods omitted
- *   }
- * }
- * </pre>
- * 
- * <p>Although the above solves the problem, it is not recommended. The best solution
- * is to define the constants in the enum class, and hold references in the outer class:
- *
- * <pre>
- * public final class Outer {
- *   public static final BWEnum BLACK = BWEnum.BLACK;
- *   public static final BWEnum WHITE = BWEnum.WHITE;
- *
- *   // static nested enum class
- *   public static final class BWEnum extends Enum {
- *     // only define constants in enum classes - private if desired
- *     private static final BWEnum BLACK = new BWEnum("Black");
- *     private static final BWEnum WHITE = new BWEnum("White");
- * 
- *     // ... other methods omitted
- *   }
- * }
- * </pre>
- * 
- * <p>For more details, see the 'Nested' test cases.
- * 
- * @deprecated Replaced by {@link org.apache.commons.lang.enums.Enum org.apache.commons.lang.enums.Enum} 
- *          and will be removed in version 3.0. All classes in this package are deprecated and repackaged to 
- *          {@link org.apache.commons.lang.enums} since <code>enum</code> is a Java 1.5 keyword. 
- * @see org.apache.commons.lang.enums.Enum
- * @author Apache Avalon project
- * @author Stephen Colebourne
- * @author Chris Webb
- * @author Mike Bowler
- * @since 1.0
- * @version $Id$
- */
-public abstract class Enum implements Comparable, Serializable {
-
-    /**
-     * Required for serialization support. Lang version 1.0.1 serial compatibility.
-     * 
-     * @see java.io.Serializable
-     */
-    private static final long serialVersionUID = -487045951170455942L;
-    
-    // After discussion, the default size for HashMaps is used, as the
-    // sizing algorithm changes across the JDK versions
-    /**
-     * An empty <code>Map</code>, as JDK1.2 didn't have an empty map.
-     */
-    private static final Map EMPTY_MAP = Collections.unmodifiableMap(new HashMap(0));
-    
-    /**
-     * <code>Map</code>, key of class name, value of <code>Entry</code>.
-     */
-    private static Map cEnumClasses
-        // LANG-334: To avoid exposing a mutating map,
-        // we copy it each time we add to it. This is cheaper than
-        // using a synchronized map since we are almost entirely reads
-        = new WeakHashMap();
-    
-    /**
-     * The string representation of the Enum.
-     */
-    private final String iName;
-    
-    /**
-     * The hashcode representation of the Enum.
-     */
-    private transient final int iHashCode;
-    
-    /**
-     * The toString representation of the Enum.
-     * @since 2.0
-     */
-    protected transient String iToString = null;
-
-    /**
-     * <p>Enable the iterator to retain the source code order.</p>
-     */
-    private static class Entry {
-        /**
-         * Map of Enum name to Enum.
-         */
-        final Map map = new HashMap();
-        /**
-         * Map of Enum name to Enum.
-         */
-        final Map unmodifiableMap = Collections.unmodifiableMap(map);
-        /**
-         * List of Enums in source code order.
-         */
-        final List list = new ArrayList(25);
-        /**
-         * Map of Enum name to Enum.
-         */
-        final List unmodifiableList = Collections.unmodifiableList(list);
-
-        /**
-         * <p>Restrictive constructor.</p>
-         */
-        protected Entry() {
-            super();
-        }
-    }
-
-    /**
-     * <p>Constructor to add a new named item to the enumeration.</p>
-     *
-     * @param name  the name of the enum object,
-     *  must not be empty or <code>null</code>
-     * @throws IllegalArgumentException if the name is <code>null</code>
-     *  or an empty string
-     * @throws IllegalArgumentException if the getEnumClass() method returns
-     *  a null or invalid Class
-     */
-    protected Enum(String name) {
-        super();
-        init(name);
-        iName = name;
-        iHashCode = 7 + getEnumClass().hashCode() + 3 * name.hashCode();
-        // cannot create toString here as subclasses may want to include other data
-    }
-
-    /**
-     * Initializes the enumeration.
-     * 
-     * @param name  the enum name
-     * @throws IllegalArgumentException if the name is null or empty or duplicate
-     * @throws IllegalArgumentException if the enumClass is null or invalid
-     */
-    private void init(String name) {
-        if (StringUtils.isEmpty(name)) {
-            throw new IllegalArgumentException("The Enum name must not be empty or null");
-        }
-        
-        Class enumClass = getEnumClass();
-        if (enumClass == null) {
-            throw new IllegalArgumentException("getEnumClass() must not be null");
-        }
-        Class cls = getClass();
-        boolean ok = false;
-        while (cls != null && cls != Enum.class && cls != ValuedEnum.class) {
-            if (cls == enumClass) {
-                ok = true;
-                break;
-            }
-            cls = cls.getSuperclass();
-        }
-        if (ok == false) {
-            throw new IllegalArgumentException("getEnumClass() must return a superclass of this class");
-        }
-
-        Entry entry;
-        synchronized( Enum.class ) { // LANG-334
-            // create entry
-            entry = (Entry) cEnumClasses.get(enumClass);
-            if (entry == null) {
-                entry = createEntry(enumClass);
-                Map myMap = new WeakHashMap( cEnumClasses );
-                myMap.put(enumClass, entry);
-                cEnumClasses = myMap;
-            }
-        }
-        if (entry.map.containsKey(name)) {
-            throw new IllegalArgumentException("The Enum name must be unique, '" + name + "' has already been added");
-        }
-        entry.map.put(name, this);
-        entry.list.add(this);
-    }
-
-    /**
-     * <p>Handle the deserialization of the class to ensure that multiple
-     * copies are not wastefully created, or illegal enum types created.</p>
-     *
-     * @return the resolved object
-     */
-    protected Object readResolve() {
-        Entry entry = (Entry) cEnumClasses.get(getEnumClass());
-        if (entry == null) {
-            return null;
-        }
-        return entry.map.get(getName());
-    }
-    
-    //--------------------------------------------------------------------------------
-
-    /**
-     * <p>Gets an <code>Enum</code> object by class and name.</p>
-     * 
-     * @param enumClass  the class of the Enum to get, must not
-     *  be <code>null</code>
-     * @param name  the name of the <code>Enum</code> to get,
-     *  may be <code>null</code>
-     * @return the enum object, or <code>null</code> if the enum does not exist
-     * @throws IllegalArgumentException if the enum class
-     *  is <code>null</code>
-     */
-    protected static Enum getEnum(Class enumClass, String name) {
-        Entry entry = getEntry(enumClass);
-        if (entry == null) {
-            return null;
-        }
-        return (Enum) entry.map.get(name);
-    }
-
-    /**
-     * <p>Gets the <code>Map</code> of <code>Enum</code> objects by
-     * name using the <code>Enum</code> class.</p>
-     *
-     * <p>If the requested class has no enum objects an empty
-     * <code>Map</code> is returned.</p>
-     * 
-     * @param enumClass  the class of the <code>Enum</code> to get,
-     *  must not be <code>null</code>
-     * @return the enum object Map
-     * @throws IllegalArgumentException if the enum class is <code>null</code>
-     * @throws IllegalArgumentException if the enum class is not a subclass of Enum
-     */
-    protected static Map getEnumMap(Class enumClass) {
-        Entry entry = getEntry(enumClass);
-        if (entry == null) {
-            return EMPTY_MAP;
-        }
-        return entry.unmodifiableMap;
-    }
-
-    /**
-     * <p>Gets the <code>List</code> of <code>Enum</code> objects using the
-     * <code>Enum</code> class.</p>
-     *
-     * <p>The list is in the order that the objects were created (source code order).
-     * If the requested class has no enum objects an empty <code>List</code> is
-     * returned.</p>
-     * 
-     * @param enumClass  the class of the <code>Enum</code> to get,
-     *  must not be <code>null</code>
-     * @return the enum object Map
-     * @throws IllegalArgumentException if the enum class is <code>null</code>
-     * @throws IllegalArgumentException if the enum class is not a subclass of Enum
-     */
-    protected static List getEnumList(Class enumClass) {
-        Entry entry = getEntry(enumClass);
-        if (entry == null) {
-            return Collections.EMPTY_LIST;
-        }
-        return entry.unmodifiableList;
-    }
-
-    /**
-     * <p>Gets an <code>Iterator</code> over the <code>Enum</code> objects in
-     * an <code>Enum</code> class.</p>
-     *
-     * <p>The <code>Iterator</code> is in the order that the objects were
-     * created (source code order). If the requested class has no enum
-     * objects an empty <code>Iterator</code> is returned.</p>
-     * 
-     * @param enumClass  the class of the <code>Enum</code> to get,
-     *  must not be <code>null</code>
-     * @return an iterator of the Enum objects
-     * @throws IllegalArgumentException if the enum class is <code>null</code>
-     * @throws IllegalArgumentException if the enum class is not a subclass of Enum
-     */
-    protected static Iterator iterator(Class enumClass) {
-        return Enum.getEnumList(enumClass).iterator();
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Gets an <code>Entry</code> from the map of Enums.</p>
-     * 
-     * @param enumClass  the class of the <code>Enum</code> to get
-     * @return the enum entry
-     */
-    private static Entry getEntry(Class enumClass) {
-        if (enumClass == null) {
-            throw new IllegalArgumentException("The Enum Class must not be null");
-        }
-        if (Enum.class.isAssignableFrom(enumClass) == false) {
-            throw new IllegalArgumentException("The Class must be a subclass of Enum");
-        }
-        Entry entry = (Entry) cEnumClasses.get(enumClass);
-        return entry;
-    }
-    
-    /**
-     * <p>Creates an <code>Entry</code> for storing the Enums.</p>
-     *
-     * <p>This accounts for subclassed Enums.</p>
-     * 
-     * @param enumClass  the class of the <code>Enum</code> to get
-     * @return the enum entry
-     */
-    private static Entry createEntry(Class enumClass) {
-        Entry entry = new Entry();
-        Class cls = enumClass.getSuperclass();
-        while (cls != null && cls != Enum.class && cls != ValuedEnum.class) {
-            Entry loopEntry = (Entry) cEnumClasses.get(cls);
-            if (loopEntry != null) {
-                entry.list.addAll(loopEntry.list);
-                entry.map.putAll(loopEntry.map);
-                break;  // stop here, as this will already have had superclasses added
-            }
-            cls = cls.getSuperclass();
-        }
-        return entry;
-    }
-    
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Retrieve the name of this Enum item, set in the constructor.</p>
-     * 
-     * @return the <code>String</code> name of this Enum item
-     */
-    public final String getName() {
-        return iName;
-    }
-
-    /**
-     * <p>Retrieves the Class of this Enum item, set in the constructor.</p>
-     * 
-     * <p>This is normally the same as <code>getClass()</code>, but for
-     * advanced Enums may be different. If overridden, it must return a
-     * constant value.</p>
-     * 
-     * @return the <code>Class</code> of the enum
-     * @since 2.0
-     */
-    public Class getEnumClass() {
-        return getClass();
-    }
-
-    /**
-     * <p>Tests for equality.</p>
-     *
-     * <p>Two Enum objects are considered equal
-     * if they have the same class names and the same names.
-     * Identity is tested for first, so this method usually runs fast.</p>
-     * 
-     * <p>If the parameter is in a different class loader than this instance,
-     * reflection is used to compare the names.</p>
-     *
-     * @param other  the other object to compare for equality
-     * @return <code>true</code> if the Enums are equal
-     */
-    public final boolean equals(Object other) {
-        if (other == this) {
-            return true;
-        } else if (other == null) {
-            return false;
-        } else if (other.getClass() == this.getClass()) {
-            // Ok to do a class cast to Enum here since the test above
-            // guarantee both
-            // classes are in the same class loader.
-            return iName.equals(((Enum) other).iName);
-        } else {
-            // This and other are in different class loaders, we must check indirectly
-            if (other.getClass().getName().equals(this.getClass().getName()) == false) {
-                return false;
-            }
-            return iName.equals( getNameInOtherClassLoader(other) );
-        }
-    }
-    
-    /**
-     * <p>Returns a suitable hashCode for the enumeration.</p>
-     *
-     * @return a hashcode based on the name
-     */
-    public final int hashCode() {
-        return iHashCode;
-    }
-
-    /**
-     * <p>Tests for order.</p>
-     *
-     * <p>The default ordering is alphabetic by name, but this
-     * can be overridden by subclasses.</p>
-     * 
-     * <p>If the parameter is in a different class loader than this instance,
-     * reflection is used to compare the names.</p>
-     *
-     * @see java.lang.Comparable#compareTo(Object)
-     * @param other  the other object to compare to
-     * @return -ve if this is less than the other object, +ve if greater
-     *  than, <code>0</code> of equal
-     * @throws ClassCastException if other is not an Enum
-     * @throws NullPointerException if other is <code>null</code>
-     */
-    public int compareTo(Object other) {
-        if (other == this) {
-            return 0;
-        }
-        if (other.getClass() != this.getClass()) {
-            if (other.getClass().getName().equals(this.getClass().getName())) {
-                return iName.compareTo( getNameInOtherClassLoader(other) );
-            }
-            throw new ClassCastException(
-                    "Different enum class '" + ClassUtils.getShortClassName(other.getClass()) + "'");
-        }
-        return iName.compareTo(((Enum) other).iName);
-    }
-
-    /**
-     * <p>Use reflection to return an objects class name.</p>
-     *
-     * @param other The object to determine the class name for
-     * @return The class name
-     */
-    private String getNameInOtherClassLoader(Object other) {
-        try {
-            Method mth = other.getClass().getMethod("getName", null);
-            String name = (String) mth.invoke(other, null);
-            return name;
-        } catch (NoSuchMethodException e) {
-            // ignore - should never happen
-        } catch (IllegalAccessException e) {
-            // ignore - should never happen
-        } catch (InvocationTargetException e) {
-            // ignore - should never happen
-        }
-        throw new IllegalStateException("This should not happen");
-    }
-
-    /**
-     * <p>Human readable description of this Enum item.</p>
-     * 
-     * @return String in the form <code>type[name]</code>, for example:
-     * <code>Color[Red]</code>. Note that the package name is stripped from
-     * the type name.
-     */
-    public String toString() {
-        if (iToString == null) {
-            String shortName = ClassUtils.getShortClassName(getEnumClass());
-            iToString = shortName + "[" + getName() + "]";
-        }
-        return iToString;
-    }
-    
-}
diff --git a/src/java/org/apache/commons/lang/enum/EnumUtils.java b/src/java/org/apache/commons/lang/enum/EnumUtils.java
deleted file mode 100644
index a2d527d4..00000000
--- a/src/java/org/apache/commons/lang/enum/EnumUtils.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * <p>Utility class for accessing and manipulating {@link Enum}s.</p>
- *
- * @deprecated Replaced by {@link org.apache.commons.lang.enums.EnumUtils org.apache.commons.lang.enums.EnumUtils} 
- *          and will be removed in version 3.0. All classes in this package are deprecated and repackaged to 
- *          {@link org.apache.commons.lang.enums} since <code>enum</code> is a Java 1.5 keyword. 
- * @see org.apache.commons.lang.enums.EnumUtils
- * @see Enum
- * @see ValuedEnum
- * @author Stephen Colebourne
- * @author Gary Gregory
- * @since 1.0
- * @version $Id$
- */
-public class EnumUtils {
-
-    /**
-     * Public constructor. This class should not normally be instantiated.
-     * @since 2.0
-     */
-    public EnumUtils() {
-        super();
-    }
-
-    /**
-     * <p>Gets an <code>Enum</code> object by class and name.</p>
-     * 
-     * @param enumClass  the class of the <code>Enum</code> to get
-     * @param name  the name of the Enum to get, may be <code>null</code>
-     * @return the enum object
-     * @throws IllegalArgumentException if the enum class is <code>null</code>
-     */
-    public static Enum getEnum(Class enumClass, String name) {
-        return Enum.getEnum(enumClass, name);
-    }
-
-    /**
-     * <p>Gets a <code>ValuedEnum</code> object by class and value.</p>
-     * 
-     * @param enumClass  the class of the <code>Enum</code> to get
-     * @param value  the value of the <code>Enum</code> to get
-     * @return the enum object, or null if the enum does not exist
-     * @throws IllegalArgumentException if the enum class is <code>null</code>
-     */
-    public static ValuedEnum getEnum(Class enumClass, int value) {
-        return (ValuedEnum) ValuedEnum.getEnum(enumClass, value);
-    }
-
-    /**
-     * <p>Gets the <code>Map</code> of <code>Enum</code> objects by
-     * name using the <code>Enum</code> class.</p>
-     *
-     * <p>If the requested class has no enum objects an empty
-     * <code>Map</code> is returned. The <code>Map</code> is unmodifiable.</p>
-     * 
-     * @param enumClass  the class of the <code>Enum</code> to get
-     * @return the enum object Map
-     * @throws IllegalArgumentException if the enum class is <code>null</code>
-     * @throws IllegalArgumentException if the enum class is not a subclass
-     *  of <code>Enum</code>
-     */
-    public static Map getEnumMap(Class enumClass) {
-        return Enum.getEnumMap(enumClass);
-    }
-
-    /**
-     * <p>Gets the <code>List</code> of <code>Enum</code> objects using
-     * the <code>Enum</code> class.</p>
-     *
-     * <p>The list is in the order that the objects were created
-     * (source code order).</p>
-     *
-     * <p>If the requested class has no enum objects an empty
-     * <code>List</code> is returned. The <code>List</code> is unmodifiable.</p>
-     * 
-     * @param enumClass  the class of the Enum to get
-     * @return the enum object Map
-     * @throws IllegalArgumentException if the enum class is <code>null</code>
-     * @throws IllegalArgumentException if the enum class is not a subclass
-     *  of <code>Enum</code>
-     */
-    public static List getEnumList(Class enumClass) {
-        return Enum.getEnumList(enumClass);
-    }
-
-    /**
-     * <p>Gets an <code>Iterator</code> over the <code>Enum</code> objects
-     * in an <code>Enum</code> class.</p>
-     *
-     * <p>The iterator is in the order that the objects were created
-     * (source code order).</p>
-     *
-     * <p>If the requested class has no enum objects an empty
-     * <code>Iterator</code> is returned. The <code>Iterator</code>
-     * is unmodifiable.</p>
-     * 
-     * @param enumClass  the class of the <code>Enum</code> to get
-     * @return an <code>Iterator</code> of the <code>Enum</code> objects
-     * @throws IllegalArgumentException if the enum class is <code>null</code>
-     * @throws IllegalArgumentException if the enum class is not a subclass of <code>Enum</code>
-     */
-    public static Iterator iterator(Class enumClass) {
-        return Enum.getEnumList(enumClass).iterator();
-    }
-    
-}
diff --git a/src/java/org/apache/commons/lang/enum/ValuedEnum.java b/src/java/org/apache/commons/lang/enum/ValuedEnum.java
deleted file mode 100644
index 5874f29b..00000000
--- a/src/java/org/apache/commons/lang/enum/ValuedEnum.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-
-import org.apache.commons.lang.ClassUtils;
-
-/**
- * <p>Abstract superclass for type-safe enums with integer values suitable
- * for use in <code>switch</code> statements.</p>
- *
- * <p><em>NOTE:</em>Due to the way in which Java ClassLoaders work, comparing
- * <code>Enum</code> objects should always be done using the equals() method,
- * not <code>==</code>. The equals() method will try <code>==</code> first so
- * in most cases the effect is the same.</p>
- *
- * <p>To use this class, it must be subclassed. For example:</p>
- *
- * <pre>
- * public final class JavaVersionEnum extends ValuedEnum {
- *   //standard enums for version of JVM
- *   public static final int  JAVA1_0_VALUE  = 100;
- *   public static final int  JAVA1_1_VALUE  = 110;
- *   public static final int  JAVA1_2_VALUE  = 120;
- *   public static final int  JAVA1_3_VALUE  = 130;
- *   public static final JavaVersionEnum  JAVA1_0  = new JavaVersionEnum( "Java 1.0", JAVA1_0_VALUE );
- *   public static final JavaVersionEnum  JAVA1_1  = new JavaVersionEnum( "Java 1.1", JAVA1_1_VALUE );
- *   public static final JavaVersionEnum  JAVA1_2  = new JavaVersionEnum( "Java 1.2", JAVA1_2_VALUE );
- *   public static final JavaVersionEnum  JAVA1_3  = new JavaVersionEnum( "Java 1.3", JAVA1_3_VALUE );
- *
- *   private JavaVersionEnum(String name, int value) {
- *     super( name, value );
- *   }
- * 
- *   public static JavaVersionEnum getEnum(String javaVersion) {
- *     return (JavaVersionEnum) getEnum(JavaVersionEnum.class, javaVersion);
- *   }
- * 
- *   public static JavaVersionEnum getEnum(int javaVersion) {
- *     return (JavaVersionEnum) getEnum(JavaVersionEnum.class, javaVersion);
- *   }
- * 
- *   public static Map getEnumMap() {
- *     return getEnumMap(JavaVersionEnum.class);
- *   }
- * 
- *   public static List getEnumList() {
- *     return getEnumList(JavaVersionEnum.class);
- *   }
- * 
- *   public static Iterator iterator() {
- *     return iterator(JavaVersionEnum.class);
- *   }
- * }
- * </pre>
- *
- * <p>The above class could then be used as follows:</p>
- *
- * <pre>
- * public void doSomething(JavaVersionEnum ver) {
- *   switch (ver.getValue()) {
- *     case JAVA1_0_VALUE:
- *       // ...
- *       break;
- *     case JAVA1_1_VALUE:
- *       // ...
- *       break;
- *     //...
- *   }
- * }
- * </pre>
- *
- * <p>As shown, each enum has a name and a value. These can be accessed using
- * <code>getName</code> and <code>getValue</code>.</p>
- *
- * <p>The <code>getEnum</code> and <code>iterator</code> methods are recommended.
- * Unfortunately, Java restrictions require these to be coded as shown in each subclass.
- * An alternative choice is to use the {@link EnumUtils} class.</p>
- *
- * @deprecated Replaced by {@link org.apache.commons.lang.enums.ValuedEnum org.apache.commons.lang.enums.ValuedEnum}
- *          and will be removed in version 3.0. All classes in this package are deprecated and repackaged to 
- *          {@link org.apache.commons.lang.enums} since <code>enum</code> is a Java 1.5 keyword. 
- * @see org.apache.commons.lang.enums.ValuedEnum
- * @author Apache Avalon project
- * @author Stephen Colebourne
- * @since 1.0
- * @version $Id$
- */
-public abstract class ValuedEnum extends Enum {
-    
-    /**
-     * Required for serialization support. Lang version 1.0.1 serial compatibility.
-     * 
-     * @see java.io.Serializable
-     */
-    private static final long serialVersionUID = -7129650521543789085L;
-    
-    /**
-     * The value contained in enum.
-     */
-    private final int iValue;
-
-    /**
-     * Constructor for enum item.
-     *
-     * @param name  the name of enum item
-     * @param value  the value of enum item
-     */
-    protected ValuedEnum(String name, int value) {
-        super(name);
-        iValue = value;
-    }
-
-    /**
-     * <p>Gets an <code>Enum</code> object by class and value.</p>
-     *
-     * <p>This method loops through the list of <code>Enum</code>,
-     * thus if there are many <code>Enum</code>s this will be
-     * slow.</p>
-     * 
-     * @param enumClass  the class of the <code>Enum</code> to get
-     * @param value  the value of the <code>Enum</code> to get
-     * @return the enum object, or null if the enum does not exist
-     * @throws IllegalArgumentException if the enum class is <code>null</code>
-     */
-    protected static Enum getEnum(Class enumClass, int value) {
-        if (enumClass == null) {
-            throw new IllegalArgumentException("The Enum Class must not be null");
-        }
-        List list = Enum.getEnumList(enumClass);
-        for (Iterator it = list.iterator(); it.hasNext();) {
-            ValuedEnum enumeration = (ValuedEnum) it.next();
-            if (enumeration.getValue() == value) {
-                return enumeration;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * <p>Get value of enum item.</p>
-     *
-     * @return the enum item's value.
-     */
-    public final int getValue() {
-        return iValue;
-    }
-
-    /**
-     * <p>Tests for order.</p>
-     *
-     * <p>The default ordering is numeric by value, but this
-     * can be overridden by subclasses.</p>
-     * 
-     * @see java.lang.Comparable#compareTo(Object)
-     * @param other  the other object to compare to
-     * @return -ve if this is less than the other object, +ve if greater than,
-     *  <code>0</code> of equal
-     * @throws ClassCastException if other is not an <code>Enum</code>
-     * @throws NullPointerException if other is <code>null</code>
-     */
-    public int compareTo(Object other) {
-        return iValue - ((ValuedEnum) other).iValue;
-    }
-
-    /**
-     * <p>Human readable description of this <code>Enum</code> item.</p>
-     *
-     * @return String in the form <code>type[name=value]</code>, for example:
-     *  <code>JavaVersion[Java 1.0=100]</code>. Note that the package name is
-     *  stripped from the type name.
-     */
-    public String toString() {
-        if (iToString == null) {
-            String shortName = ClassUtils.getShortClassName(getEnumClass());
-            iToString = shortName + "[" + getName() + "=" + getValue() + "]";
-        }
-        return iToString;
-    }
-}
diff --git a/src/java/org/apache/commons/lang/enum/package.html b/src/java/org/apache/commons/lang/enum/package.html
deleted file mode 100644
index 0eeb42b9..00000000
--- a/src/java/org/apache/commons/lang/enum/package.html
+++ /dev/null
@@ -1,62 +0,0 @@
-<!--
-Licensed to the Apache Software Foundation (ASF) under one or more
-contributor license agreements.  See the NOTICE file distributed with
-this work for additional information regarding copyright ownership.
-The ASF licenses this file to You under the Apache License, Version 2.0
-(the "License"); you may not use this file except in compliance with
-the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
--->
-<html>
-<body>
-<p>
-<b>Deprecated</b> and replaced by {@link org.apache.commons.lang.enums}
-and will be removed in version 3.0. 
-</p>
-<p>
-All classes in this package are deprecated and repackaged to {@link org.apache.commons.lang.enums}
-since <code>enum</code> is a Java 1.5 keyword.
-</p>
-<p>
-Provides an implementation of the C style <code>enum</code> in the Java world.
-</p>
-<p>
-The classic example being an RGB color enumeration.
-</p>
-<pre>
-public final class ColorEnum extends Enum {
-    public static final ColorEnum RED = new ColorEnum("Red");
-    public static final ColorEnum GREEN = new ColorEnum("Green");
-    public static final ColorEnum BLUE = new ColorEnum("Blue");
-
-    private ColorEnum(String color) {
-        super(color);
-    }
-
-    public static ColorEnum getEnum(String color) {
-        return (ColorEnum) getEnum(ColorEnum.class, color);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(ColorEnum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(ColorEnum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(ColorEnum.class);
-    }
-}
-</pre>
-@since 1.0
-</body>
-</html>
diff --git a/src/java/org/apache/commons/lang/time/FastDateFormat.java.orig b/src/java/org/apache/commons/lang/time/FastDateFormat.java.orig
deleted file mode 100644
index 8a26f283..00000000
--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java.orig
+++ /dev/null
@@ -1,1751 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.time;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.text.DateFormat;
-import java.text.DateFormatSymbols;
-import java.text.FieldPosition;
-import java.text.Format;
-import java.text.ParsePosition;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.TimeZone;
-
-import org.apache.commons.lang.Validate;
-
-/**
- * <p>FastDateFormat is a fast and thread-safe version of
- * {@link java.text.SimpleDateFormat}.</p>
- * 
- * <p>This class can be used as a direct replacement to
- * <code>SimpleDateFormat</code> in most formatting situations.
- * This class is especially useful in multi-threaded server environments.
- * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,
- * nor will it be as Sun have closed the bug/RFE.
- * </p>
- *
- * <p>Only formatting is supported, but all patterns are compatible with
- * SimpleDateFormat (except time zones - see below).</p>
- *
- * <p>Java 1.4 introduced a new pattern letter, <code>'Z'</code>, to represent
- * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).
- * This pattern letter can be used here (on all JDK versions).</p>
- *
- * <p>In addition, the pattern <code>'ZZ'</code> has been made to represent
- * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).
- * This introduces a minor incompatibility with Java 1.4, but at a gain of
- * useful functionality.</p>
- *
- * @author TeaTrove project
- * @author Brian S O'Neill
- * @author Sean Schofield
- * @author Gary Gregory
- * @author Stephen Colebourne
- * @author Nikolay Metchev
- * @since 2.0
- * @version $Id$
- */
-public class FastDateFormat extends Format {
-    // A lot of the speed in this class comes from caching, but some comes
-    // from the special int to StringBuffer conversion.
-    //
-    // The following produces a padded 2 digit number:
-    //   buffer.append((char)(value / 10 + '0'));
-    //   buffer.append((char)(value % 10 + '0'));
-    //
-    // Note that the fastest append to StringBuffer is a single char (used here).
-    // Note that Integer.toString() is not called, the conversion is simply
-    // taking the value and adding (mathematically) the ASCII value for '0'.
-    // So, don't change this code! It works and is very fast.
-    
-    /**
-     * Required for serialization support.
-     * 
-     * @see java.io.Serializable
-     */
-    private static final long serialVersionUID = 1L;
-
-    /**
-     * FULL locale dependent date or time style.
-     */
-    public static final int FULL = DateFormat.FULL;
-    /**
-     * LONG locale dependent date or time style.
-     */
-    public static final int LONG = DateFormat.LONG;
-    /**
-     * MEDIUM locale dependent date or time style.
-     */
-    public static final int MEDIUM = DateFormat.MEDIUM;
-    /**
-     * SHORT locale dependent date or time style.
-     */
-    public static final int SHORT = DateFormat.SHORT;
-    
-    private static String cDefaultPattern;
-
-    private static Map cInstanceCache = new HashMap(7);
-    private static Map cDateInstanceCache = new HashMap(7);
-    private static Map cTimeInstanceCache = new HashMap(7);
-    private static Map cDateTimeInstanceCache = new HashMap(7);
-    private static Map cTimeZoneDisplayCache = new HashMap(7);
-
-    /**
-     * The pattern.
-     */
-    private final String mPattern;
-    /**
-     * The time zone.
-     */
-    private final TimeZone mTimeZone;
-    /**
-     * Whether the time zone overrides any on Calendars.
-     */
-    private final boolean mTimeZoneForced;
-    /**
-     * The locale.
-     */
-    private final Locale mLocale;
-    /**
-     * Whether the locale overrides the default.
-     */
-    private final boolean mLocaleForced;
-    /**
-     * The parsed rules.
-     */
-    private transient Rule[] mRules;
-    /**
-     * The estimated maximum length.
-     */
-    private transient int mMaxLengthEstimate;
-
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Gets a formatter instance using the default pattern in the
-     * default locale.</p>
-     * 
-     * @return a date/time formatter
-     */
-    public static FastDateFormat getInstance() {
-        return getInstance(getDefaultPattern(), null, null);
-    }
-
-    /**
-     * <p>Gets a formatter instance using the specified pattern in the
-     * default locale.</p>
-     * 
-     * @param pattern  {@link java.text.SimpleDateFormat} compatible
-     *  pattern
-     * @return a pattern based date/time formatter
-     * @throws IllegalArgumentException if pattern is invalid
-     */
-    public static FastDateFormat getInstance(String pattern) {
-        return getInstance(pattern, null, null);
-    }
-
-    /**
-     * <p>Gets a formatter instance using the specified pattern and
-     * time zone.</p>
-     * 
-     * @param pattern  {@link java.text.SimpleDateFormat} compatible
-     *  pattern
-     * @param timeZone  optional time zone, overrides time zone of
-     *  formatted date
-     * @return a pattern based date/time formatter
-     * @throws IllegalArgumentException if pattern is invalid
-     */
-    public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
-        return getInstance(pattern, timeZone, null);
-    }
-
-    /**
-     * <p>Gets a formatter instance using the specified pattern and
-     * locale.</p>
-     * 
-     * @param pattern  {@link java.text.SimpleDateFormat} compatible
-     *  pattern
-     * @param locale  optional locale, overrides system locale
-     * @return a pattern based date/time formatter
-     * @throws IllegalArgumentException if pattern is invalid
-     */
-    public static FastDateFormat getInstance(String pattern, Locale locale) {
-        return getInstance(pattern, null, locale);
-    }
-
-    /**
-     * <p>Gets a formatter instance using the specified pattern, time zone
-     * and locale.</p>
-     * 
-     * @param pattern  {@link java.text.SimpleDateFormat} compatible
-     *  pattern
-     * @param timeZone  optional time zone, overrides time zone of
-     *  formatted date
-     * @param locale  optional locale, overrides system locale
-     * @return a pattern based date/time formatter
-     * @throws IllegalArgumentException if pattern is invalid
-     *  or <code>null</code>
-     */
-    public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
-        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
-        FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
-        if (format == null) {
-            format = emptyFormat;
-            format.init();  // convert shell format into usable one
-            cInstanceCache.put(format, format);  // this is OK!
-        }
-        return format;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Gets a date formatter instance using the specified style in the
-     * default time zone and locale.</p>
-     * 
-     * @param style  date style: FULL, LONG, MEDIUM, or SHORT
-     * @return a localized standard date formatter
-     * @throws IllegalArgumentException if the Locale has no date
-     *  pattern defined
-     * @since 2.1
-     */
-    public static FastDateFormat getDateInstance(int style) {
-        return getDateInstance(style, null, null);
-    }
-
-    /**
-     * <p>Gets a date formatter instance using the specified style and
-     * locale in the default time zone.</p>
-     * 
-     * @param style  date style: FULL, LONG, MEDIUM, or SHORT
-     * @param locale  optional locale, overrides system locale
-     * @return a localized standard date formatter
-     * @throws IllegalArgumentException if the Locale has no date
-     *  pattern defined
-     * @since 2.1
-     */
-    public static FastDateFormat getDateInstance(int style, Locale locale) {
-        return getDateInstance(style, null, locale);
-    }
-
-    /**
-     * <p>Gets a date formatter instance using the specified style and
-     * time zone in the default locale.</p>
-     * 
-     * @param style  date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone  optional time zone, overrides time zone of
-     *  formatted date
-     * @return a localized standard date formatter
-     * @throws IllegalArgumentException if the Locale has no date
-     *  pattern defined
-     * @since 2.1
-     */
-    public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
-        return getDateInstance(style, timeZone, null);
-    }
-    /**
-     * <p>Gets a date formatter instance using the specified style, time
-     * zone and locale.</p>
-     * 
-     * @param style  date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone  optional time zone, overrides time zone of
-     *  formatted date
-     * @param locale  optional locale, overrides system locale
-     * @return a localized standard date formatter
-     * @throws IllegalArgumentException if the Locale has no date
-     *  pattern defined
-     */
-    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
-        Object key = new Integer(style);
-        if (timeZone != null) {
-            key = new Pair(key, timeZone);
-        }
-
-        if (locale != null) {
-            key = new Pair(key, locale);
-        }
-
-
-        FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
-        if (format == null) {
-            if (locale == null) {
-                locale = Locale.getDefault();
-            }
-            try {
-                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
-                String pattern = formatter.toPattern();
-                format = getInstance(pattern, timeZone, locale);
-                cDateInstanceCache.put(key, format);
-                
-            } catch (ClassCastException ex) {
-                throw new IllegalArgumentException("No date pattern for locale: " + locale);
-            }
-        }
-        return format;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Gets a time formatter instance using the specified style in the
-     * default time zone and locale.</p>
-     * 
-     * @param style  time style: FULL, LONG, MEDIUM, or SHORT
-     * @return a localized standard time formatter
-     * @throws IllegalArgumentException if the Locale has no time
-     *  pattern defined
-     * @since 2.1
-     */
-    public static FastDateFormat getTimeInstance(int style) {
-        return getTimeInstance(style, null, null);
-    }
-
-    /**
-     * <p>Gets a time formatter instance using the specified style and
-     * locale in the default time zone.</p>
-     * 
-     * @param style  time style: FULL, LONG, MEDIUM, or SHORT
-     * @param locale  optional locale, overrides system locale
-     * @return a localized standard time formatter
-     * @throws IllegalArgumentException if the Locale has no time
-     *  pattern defined
-     * @since 2.1
-     */
-    public static FastDateFormat getTimeInstance(int style, Locale locale) {
-        return getTimeInstance(style, null, locale);
-    }
-    
-    /**
-     * <p>Gets a time formatter instance using the specified style and
-     * time zone in the default locale.</p>
-     * 
-     * @param style  time style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone  optional time zone, overrides time zone of
-     *  formatted time
-     * @return a localized standard time formatter
-     * @throws IllegalArgumentException if the Locale has no time
-     *  pattern defined
-     * @since 2.1
-     */
-    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
-        return getTimeInstance(style, timeZone, null);
-    }
-    
-    /**
-     * <p>Gets a time formatter instance using the specified style, time
-     * zone and locale.</p>
-     * 
-     * @param style  time style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone  optional time zone, overrides time zone of
-     *  formatted time
-     * @param locale  optional locale, overrides system locale
-     * @return a localized standard time formatter
-     * @throws IllegalArgumentException if the Locale has no time
-     *  pattern defined
-     */
-    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
-        Object key = new Integer(style);
-        if (timeZone != null) {
-            key = new Pair(key, timeZone);
-        }
-        if (locale != null) {
-            key = new Pair(key, locale);
-        }
-
-        FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);
-        if (format == null) {
-            if (locale == null) {
-                locale = Locale.getDefault();
-            }
-
-            try {
-                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
-                String pattern = formatter.toPattern();
-                format = getInstance(pattern, timeZone, locale);
-                cTimeInstanceCache.put(key, format);
-            
-            } catch (ClassCastException ex) {
-                throw new IllegalArgumentException("No date pattern for locale: " + locale);
-            }
-        }
-        return format;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Gets a date/time formatter instance using the specified style
-     * in the default time zone and locale.</p>
-     * 
-     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
-     * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time
-     *  pattern defined
-     * @since 2.1
-     */
-    public static FastDateFormat getDateTimeInstance(
-            int dateStyle, int timeStyle) {
-        return getDateTimeInstance(dateStyle, timeStyle, null, null);
-    }
-    
-    /**
-     * <p>Gets a date/time formatter instance using the specified style and
-     * locale in the default time zone.</p>
-     * 
-     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
-     * @param locale  optional locale, overrides system locale
-     * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time
-     *  pattern defined
-     * @since 2.1
-     */
-    public static FastDateFormat getDateTimeInstance(
-            int dateStyle, int timeStyle, Locale locale) {
-        return getDateTimeInstance(dateStyle, timeStyle, null, locale);
-    }
-    
-    /**
-     * <p>Gets a date/time formatter instance using the specified style and
-     * time zone in the default locale.</p>
-     * 
-     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone  optional time zone, overrides time zone of
-     *  formatted date
-     * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time
-     *  pattern defined
-     * @since 2.1
-     */
-    public static FastDateFormat getDateTimeInstance(
-            int dateStyle, int timeStyle, TimeZone timeZone) {
-        return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
-    }    
-    /**
-     * <p>Gets a date/time formatter instance using the specified style,
-     * time zone and locale.</p>
-     * 
-     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
-     * @param timeZone  optional time zone, overrides time zone of
-     *  formatted date
-     * @param locale  optional locale, overrides system locale
-     * @return a localized standard date/time formatter
-     * @throws IllegalArgumentException if the Locale has no date/time
-     *  pattern defined
-     */
-    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,
-            Locale locale) {
-
-        Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));
-        if (timeZone != null) {
-            key = new Pair(key, timeZone);
-        }
-        if (locale != null) {
-            key = new Pair(key, locale);
-        }
-
-        FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
-        if (format == null) {
-            if (locale == null) {
-                locale = Locale.getDefault();
-            }
-            try {
-                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
-                        locale);
-                String pattern = formatter.toPattern();
-                format = getInstance(pattern, timeZone, locale);
-                cDateTimeInstanceCache.put(key, format);
-
-            } catch (ClassCastException ex) {
-                throw new IllegalArgumentException("No date time pattern for locale: " + locale);
-            }
-        }
-        return format;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Gets the time zone display name, using a cache for performance.</p>
-     * 
-     * @param tz  the zone to query
-     * @param daylight  true if daylight savings
-     * @param style  the style to use <code>TimeZone.LONG</code>
-     *  or <code>TimeZone.SHORT</code>
-     * @param locale  the locale to use
-     * @return the textual name of the time zone
-     */
-    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
-        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
-        String value = (String) cTimeZoneDisplayCache.get(key);
-        if (value == null) {
-            // This is a very slow call, so cache the results.
-            value = tz.getDisplayName(daylight, style, locale);
-            cTimeZoneDisplayCache.put(key, value);
-        }
-        return value;
-    }
-
-    /**
-     * <p>Gets the default pattern.</p>
-     * 
-     * @return the default pattern
-     */
-    private static synchronized String getDefaultPattern() {
-        if (cDefaultPattern == null) {
-            cDefaultPattern = new SimpleDateFormat().toPattern();
-        }
-        return cDefaultPattern;
-    }
-
-    // Constructor
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Constructs a new FastDateFormat.</p>
-     * 
-     * @param pattern  {@link java.text.SimpleDateFormat} compatible
-     *  pattern
-     * @param timeZone  time zone to use, <code>null</code> means use
-     *  default for <code>Date</code> and value within for
-     *  <code>Calendar</code>
-     * @param locale  locale, <code>null</code> means use system
-     *  default
-     * @throws IllegalArgumentException if pattern is invalid or
-     *  <code>null</code>
-     */
-    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
-        super();
-        if (pattern == null) {
-            throw new IllegalArgumentException("The pattern must not be null");
-        }
-        mPattern = pattern;
-        
-        mTimeZoneForced = (timeZone != null);
-        if (timeZone == null) {
-            timeZone = TimeZone.getDefault();
-        }
-        mTimeZone = timeZone;
-        
-        mLocaleForced = (locale != null);
-        if (locale == null) {
-            locale = Locale.getDefault();
-        }
-        mLocale = locale;
-    }
-
-    /**
-     * <p>Initializes the instance for first use.</p>
-     */
-    protected void init() {
-        List rulesList = parsePattern();
-        mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);
-
-        int len = 0;
-        for (int i=mRules.length; --i >= 0; ) {
-            len += mRules[i].estimateLength();
-        }
-
-        mMaxLengthEstimate = len;
-    }
-
-    // Parse the pattern
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Returns a list of Rules given a pattern.</p>
-     * 
-     * @return a <code>List</code> of Rule objects
-     * @throws IllegalArgumentException if pattern is invalid
-     */
-    protected List parsePattern() {
-        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
-        List rules = new ArrayList();
-
-        String[] ERAs = symbols.getEras();
-        String[] months = symbols.getMonths();
-        String[] shortMonths = symbols.getShortMonths();
-        String[] weekdays = symbols.getWeekdays();
-        String[] shortWeekdays = symbols.getShortWeekdays();
-        String[] AmPmStrings = symbols.getAmPmStrings();
-
-        int length = mPattern.length();
-        int[] indexRef = new int[1];
-
-        for (int i = 0; i < length; i++) {
-            indexRef[0] = i;
-            String token = parseToken(mPattern, indexRef);
-            i = indexRef[0];
-
-            int tokenLen = token.length();
-            if (tokenLen == 0) {
-                break;
-            }
-
-            Rule rule;
-            char c = token.charAt(0);
-
-            switch (c) {
-            case 'G': // era designator (text)
-                rule = new TextField(Calendar.ERA, ERAs);
-                break;
-            case 'y': // year (number)
-                if (tokenLen >= 4) {
-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);
-                } else {
-                    rule = TwoDigitYearField.INSTANCE;
-                }
-                break;
-            case 'M': // month in year (text and number)
-                if (tokenLen >= 4) {
-                    rule = new TextField(Calendar.MONTH, months);
-                } else if (tokenLen == 3) {
-                    rule = new TextField(Calendar.MONTH, shortMonths);
-                } else if (tokenLen == 2) {
-                    rule = TwoDigitMonthField.INSTANCE;
-                } else {
-                    rule = UnpaddedMonthField.INSTANCE;
-                }
-                break;
-            case 'd': // day in month (number)
-                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
-                break;
-            case 'h': // hour in am/pm (number, 1..12)
-                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
-                break;
-            case 'H': // hour in day (number, 0..23)
-                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
-                break;
-            case 'm': // minute in hour (number)
-                rule = selectNumberRule(Calendar.MINUTE, tokenLen);
-                break;
-            case 's': // second in minute (number)
-                rule = selectNumberRule(Calendar.SECOND, tokenLen);
-                break;
-            case 'S': // millisecond (number)
-                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
-                break;
-            case 'E': // day in week (text)
-                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
-                break;
-            case 'D': // day in year (number)
-                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
-                break;
-            case 'F': // day of week in month (number)
-                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
-                break;
-            case 'w': // week in year (number)
-                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
-                break;
-            case 'W': // week in month (number)
-                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
-                break;
-            case 'a': // am/pm marker (text)
-                rule = new TextField(Calendar.AM_PM, AmPmStrings);
-                break;
-            case 'k': // hour in day (1..24)
-                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
-                break;
-            case 'K': // hour in am/pm (0..11)
-                rule = selectNumberRule(Calendar.HOUR, tokenLen);
-                break;
-            case 'z': // time zone (text)
-                if (tokenLen >= 4) {
-                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);
-                } else {
-                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);
-                }
-                break;
-            case 'Z': // time zone (value)
-                if (tokenLen == 1) {
-                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
-                } else {
-                    rule = TimeZoneNumberRule.INSTANCE_COLON;
-                }
-                break;
-            case '\'': // literal text
-                String sub = token.substring(1);
-                if (sub.length() == 1) {
-                    rule = new CharacterLiteral(sub.charAt(0));
-                } else {
-                    rule = new StringLiteral(sub);
-                }
-                break;
-            default:
-                throw new IllegalArgumentException("Illegal pattern component: " + token);
-            }
-
-            rules.add(rule);
-        }
-
-        return rules;
-    }
-
-    /**
-     * <p>Performs the parsing of tokens.</p>
-     * 
-     * @param pattern  the pattern
-     * @param indexRef  index references
-     * @return parsed token
-     */
-    protected String parseToken(String pattern, int[] indexRef) {
-        StringBuffer buf = new StringBuffer();
-
-        int i = indexRef[0];
-        int length = pattern.length();
-
-        char c = pattern.charAt(i);
-        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
-            // Scan a run of the same character, which indicates a time
-            // pattern.
-            buf.append(c);
-
-            while (i + 1 < length) {
-                char peek = pattern.charAt(i + 1);
-                if (peek == c) {
-                    buf.append(c);
-                    i++;
-                } else {
-                    break;
-                }
-            }
-        } else {
-            // This will identify token as text.
-            buf.append('\'');
-
-            boolean inLiteral = false;
-
-            for (; i < length; i++) {
-                c = pattern.charAt(i);
-
-                if (c == '\'') {
-                    if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
-                        // '' is treated as escaped '
-                        i++;
-                        buf.append(c);
-                    } else {
-                        inLiteral = !inLiteral;
-                    }
-                } else if (!inLiteral &&
-                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
-                    i--;
-                    break;
-                } else {
-                    buf.append(c);
-                }
-            }
-        }
-
-        indexRef[0] = i;
-        return buf.toString();
-    }
-
-    /**
-     * <p>Gets an appropriate rule for the padding required.</p>
-     * 
-     * @param field  the field to get a rule for
-     * @param padding  the padding required
-     * @return a new rule with the correct padding
-     */
-    protected NumberRule selectNumberRule(int field, int padding) {
-        switch (padding) {
-        case 1:
-            return new UnpaddedNumberField(field);
-        case 2:
-            return new TwoDigitNumberField(field);
-        default:
-            return new PaddedNumberField(field, padding);
-        }
-    }
-
-    // Format methods
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Formats a <code>Date</code>, <code>Calendar</code> or
-     * <code>Long</code> (milliseconds) object.</p>
-     * 
-     * @param obj  the object to format
-     * @param toAppendTo  the buffer to append to
-     * @param pos  the position - ignored
-     * @return the buffer passed in
-     */
-    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
-        if (obj instanceof Date) {
-            return format((Date) obj, toAppendTo);
-        } else if (obj instanceof Calendar) {
-            return format((Calendar) obj, toAppendTo);
-        } else if (obj instanceof Long) {
-            return format(((Long) obj).longValue(), toAppendTo);
-        } else {
-            throw new IllegalArgumentException("Unknown class: " +
-                (obj == null ? "<null>" : obj.getClass().getName()));
-        }
-    }
-
-    /**
-     * <p>Formats a millisecond <code>long</code> value.</p>
-     * 
-     * @param millis  the millisecond value to format
-     * @return the formatted string
-     * @since 2.1
-     */
-    public String format(long millis) {
-        return format(new Date(millis));
-    }
-
-    /**
-     * <p>Formats a <code>Date</code> object.</p>
-     * 
-     * @param date  the date to format
-     * @return the formatted string
-     */
-    public String format(Date date) {
-        Calendar c = new GregorianCalendar(mTimeZone);
-        c.setTime(date);
-        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
-    }
-
-    /**
-     * <p>Formats a <code>Calendar</code> object.</p>
-     * 
-     * @param calendar  the calendar to format
-     * @return the formatted string
-     */
-    public String format(Calendar calendar) {
-        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
-    }
-
-    /**
-     * <p>Formats a milliseond <code>long</code> value into the
-     * supplied <code>StringBuffer</code>.</p>
-     * 
-     * @param millis  the millisecond value to format
-     * @param buf  the buffer to format into
-     * @return the specified string buffer
-     * @since 2.1
-     */
-    public StringBuffer format(long millis, StringBuffer buf) {
-        return format(new Date(millis), buf);
-    }
-
-    /**
-     * <p>Formats a <code>Date</code> object into the
-     * supplied <code>StringBuffer</code>.</p>
-     * 
-     * @param date  the date to format
-     * @param buf  the buffer to format into
-     * @return the specified string buffer
-     */
-    public StringBuffer format(Date date, StringBuffer buf) {
-        Calendar c = new GregorianCalendar(mTimeZone);
-        c.setTime(date);
-        return applyRules(c, buf);
-    }
-
-    /**
-     * <p>Formats a <code>Calendar</code> object into the
-     * supplied <code>StringBuffer</code>.</p>
-     * 
-     * @param calendar  the calendar to format
-     * @param buf  the buffer to format into
-     * @return the specified string buffer
-     */
-    public StringBuffer format(Calendar calendar, StringBuffer buf) {
-        if (mTimeZoneForced) {
-            calendar = (Calendar) calendar.clone();
-            calendar.setTimeZone(mTimeZone);
-        }
-        return applyRules(calendar, buf);
-    }
-
-    /**
-     * <p>Performs the formatting by applying the rules to the
-     * specified calendar.</p>
-     * 
-     * @param calendar  the calendar to format
-     * @param buf  the buffer to format into
-     * @return the specified string buffer
-     */
-    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
-        Rule[] rules = mRules;
-        int len = mRules.length;
-        for (int i = 0; i < len; i++) {
-            rules[i].appendTo(buf, calendar);
-        }
-        return buf;
-    }
-
-    // Parsing
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Parsing is not supported.</p>
-     * 
-     * @param source  the string to parse
-     * @param pos  the parsing position
-     * @return <code>null</code> as not supported
-     */
-    public Object parseObject(String source, ParsePosition pos) {
-        pos.setIndex(0);
-        pos.setErrorIndex(0);
-        return null;
-    }
-    
-    // Accessors
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Gets the pattern used by this formatter.</p>
-     * 
-     * @return the pattern, {@link java.text.SimpleDateFormat} compatible
-     */
-    public String getPattern() {
-        return mPattern;
-    }
-
-    /**
-     * <p>Gets the time zone used by this formatter.</p>
-     *
-     * <p>This zone is always used for <code>Date</code> formatting.
-     * If a <code>Calendar</code> is passed in to be formatted, the
-     * time zone on that may be used depending on
-     * {@link #getTimeZoneOverridesCalendar()}.</p>
-     * 
-     * @return the time zone
-     */
-    public TimeZone getTimeZone() {
-        return mTimeZone;
-    }
-
-    /**
-     * <p>Returns <code>true</code> if the time zone of the
-     * calendar overrides the time zone of the formatter.</p>
-     * 
-     * @return <code>true</code> if time zone of formatter
-     *  overridden for calendars
-     */
-    public boolean getTimeZoneOverridesCalendar() {
-        return mTimeZoneForced;
-    }
-
-    /**
-     * <p>Gets the locale used by this formatter.</p>
-     * 
-     * @return the locale
-     */
-    public Locale getLocale() {
-        return mLocale;
-    }
-
-    /**
-     * <p>Gets an estimate for the maximum string length that the
-     * formatter will produce.</p>
-     *
-     * <p>The actual formatted length will almost always be less than or
-     * equal to this amount.</p>
-     * 
-     * @return the maximum formatted length
-     */
-    public int getMaxLengthEstimate() {
-        return mMaxLengthEstimate;
-    }
-
-    // Basics
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Compares two objects for equality.</p>
-     * 
-     * @param obj  the object to compare to
-     * @return <code>true</code> if equal
-     */
-    public boolean equals(Object obj) {
-        if (obj instanceof FastDateFormat == false) {
-            return false;
-        }
-        FastDateFormat other = (FastDateFormat) obj;
-        if (
-            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&
-            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&
-            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&
-            (mTimeZoneForced == other.mTimeZoneForced) &&
-            (mLocaleForced == other.mLocaleForced)
-            ) {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * <p>Returns a hashcode compatible with equals.</p>
-     * 
-     * @return a hashcode compatible with equals
-     */
-    public int hashCode() {
-        int total = 0;
-        total += mPattern.hashCode();
-        total += mTimeZone.hashCode();
-        total += (mTimeZoneForced ? 1 : 0);
-        total += mLocale.hashCode();
-        total += (mLocaleForced ? 1 : 0);
-        return total;
-    }
-
-    /**
-     * <p>Gets a debugging string version of this formatter.</p>
-     * 
-     * @return a debugging string
-     */
-    public String toString() {
-        return "FastDateFormat[" + mPattern + "]";
-    }
-
-    // Serializing
-    //-----------------------------------------------------------------------
-    /**
-     * Create the object after serialization. This implementation reinitializes the 
-     * transient properties.
-     *
-     * @param in ObjectInputStream from which the object is being deserialized.
-     * @throws IOException if there is an IO issue.
-     * @throws ClassNotFoundException if a class cannot be found.
-     */
-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-        in.defaultReadObject();
-        init();
-    }
-    
-    // Rules
-    //-----------------------------------------------------------------------
-    /**
-     * <p>Inner class defining a rule.</p>
-     */
-    private interface Rule {
-        /**
-         * Returns the estimated lentgh of the result.
-         * 
-         * @return the estimated length
-         */
-        int estimateLength();
-        
-        /**
-         * Appends the value of the specified calendar to the output buffer based on the rule implementation.
-         * 
-         * @param buffer the output buffer
-         * @param calendar calendar to be appended
-         */
-        void appendTo(StringBuffer buffer, Calendar calendar);
-    }
-
-    /**
-     * <p>Inner class defining a numeric rule.</p>
-     */
-    private interface NumberRule extends Rule {
-        /**
-         * Appends the specified value to the output buffer based on the rule implementation.
-         * 
-         * @param buffer the output buffer
-         * @param value the value to be appended
-         */
-        void appendTo(StringBuffer buffer, int value);
-    }
-
-    /**
-     * <p>Inner class to output a constant single character.</p>
-     */
-    private static class CharacterLiteral implements Rule {
-        private final char mValue;
-
-        /**
-         * Constructs a new instance of <code>CharacterLiteral</code>
-         * to hold the specified value.
-         * 
-         * @param value the character literal
-         */
-        CharacterLiteral(char value) {
-            mValue = value;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return 1;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            buffer.append(mValue);
-        }
-    }
-
-    /**
-     * <p>Inner class to output a constant string.</p>
-     */
-    private static class StringLiteral implements Rule {
-        private final String mValue;
-
-        /**
-         * Constructs a new instance of <code>StringLiteral</code>
-         * to hold the specified value.
-         * 
-         * @param value the string literal
-         */
-        StringLiteral(String value) {
-            mValue = value;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return mValue.length();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            buffer.append(mValue);
-        }
-    }
-
-    /**
-     * <p>Inner class to output one of a set of values.</p>
-     */
-    private static class TextField implements Rule {
-        private final int mField;
-        private final String[] mValues;
-
-        /**
-         * Constructs an instance of <code>TextField</code>
-         * with the specified field and values.
-         * 
-         * @param field the field
-         * @param values the field values
-         */
-        TextField(int field, String[] values) {
-            mField = field;
-            mValues = values;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            int max = 0;
-            for (int i=mValues.length; --i >= 0; ) {
-                int len = mValues[i].length();
-                if (len > max) {
-                    max = len;
-                }
-            }
-            return max;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            buffer.append(mValues[calendar.get(mField)]);
-        }
-    }
-
-    /**
-     * <p>Inner class to output an unpadded number.</p>
-     */
-    private static class UnpaddedNumberField implements NumberRule {
-        static final UnpaddedNumberField INSTANCE_YEAR = new UnpaddedNumberField(Calendar.YEAR);
-        
-        private final int mField;
-
-        /**
-         * Constructs an instance of <code>UnpadedNumberField</code> with the specified field.
-         * 
-         * @param field the field
-         */
-        UnpaddedNumberField(int field) {
-            mField = field;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return 4;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            appendTo(buffer, calendar.get(mField));
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public final void appendTo(StringBuffer buffer, int value) {
-            if (value < 10) {
-                buffer.append((char)(value + '0'));
-            } else if (value < 100) {
-                buffer.append((char)(value / 10 + '0'));
-                buffer.append((char)(value % 10 + '0'));
-            } else {
-                buffer.append(Integer.toString(value));
-            }
-        }
-    }
-
-    /**
-     * <p>Inner class to output an unpadded month.</p>
-     */
-    private static class UnpaddedMonthField implements NumberRule {
-        static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();
-
-        /**
-         * Constructs an instance of <code>UnpaddedMonthField</code>.
-         *
-         */
-        UnpaddedMonthField() {
-            super();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return 2;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public final void appendTo(StringBuffer buffer, int value) {
-            if (value < 10) {
-                buffer.append((char)(value + '0'));
-            } else {
-                buffer.append((char)(value / 10 + '0'));
-                buffer.append((char)(value % 10 + '0'));
-            }
-        }
-    }
-
-    /**
-     * <p>Inner class to output a padded number.</p>
-     */
-    private static class PaddedNumberField implements NumberRule {
-        private final int mField;
-        private final int mSize;
-
-        /**
-         * Constructs an instance of <code>PaddedNumberField</code>.
-         * 
-         * @param field the field
-         * @param size size of the output field
-         */
-        PaddedNumberField(int field, int size) {
-            if (size < 3) {
-                // Should use UnpaddedNumberField or TwoDigitNumberField.
-                throw new IllegalArgumentException();
-            }
-            mField = field;
-            mSize = size;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return 4;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            appendTo(buffer, calendar.get(mField));
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public final void appendTo(StringBuffer buffer, int value) {
-            if (value < 100) {
-                for (int i = mSize; --i >= 2; ) {
-                    buffer.append('0');
-                }
-                buffer.append((char)(value / 10 + '0'));
-                buffer.append((char)(value % 10 + '0'));
-            } else {
-                int digits;
-                if (value < 1000) {
-                    digits = 3;
-                } else {
-                    Validate.isTrue(value > -1, "Negative values should not be possible", value);
-                    digits = Integer.toString(value).length();
-                }
-                for (int i = mSize; --i >= digits; ) {
-                    buffer.append('0');
-                }
-                buffer.append(Integer.toString(value));
-            }
-        }
-    }
-
-    /**
-     * <p>Inner class to output a two digit number.</p>
-     */
-    private static class TwoDigitNumberField implements NumberRule {
-        private final int mField;
-
-        /**
-         * Constructs an instance of <code>TwoDigitNumberField</code> with the specified field.
-         * 
-         * @param field the field
-         */
-        TwoDigitNumberField(int field) {
-            mField = field;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return 2;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            appendTo(buffer, calendar.get(mField));
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public final void appendTo(StringBuffer buffer, int value) {
-            if (value < 100) {
-                buffer.append((char)(value / 10 + '0'));
-                buffer.append((char)(value % 10 + '0'));
-            } else {
-                buffer.append(Integer.toString(value));
-            }
-        }
-    }
-
-    /**
-     * <p>Inner class to output a two digit year.</p>
-     */
-    private static class TwoDigitYearField implements NumberRule {
-        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();
-
-        /**
-         * Constructs an instance of <code>TwoDigitYearField</code>.
-         */
-        TwoDigitYearField() {
-            super();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return 2;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public final void appendTo(StringBuffer buffer, int value) {
-            buffer.append((char)(value / 10 + '0'));
-            buffer.append((char)(value % 10 + '0'));
-        }
-    }
-
-    /**
-     * <p>Inner class to output a two digit month.</p>
-     */
-    private static class TwoDigitMonthField implements NumberRule {
-        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();
-
-        /**
-         * Constructs an instance of <code>TwoDigitMonthField</code>.
-         */
-        TwoDigitMonthField() {
-            super();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return 2;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public final void appendTo(StringBuffer buffer, int value) {
-            buffer.append((char)(value / 10 + '0'));
-            buffer.append((char)(value % 10 + '0'));
-        }
-    }
-
-    /**
-     * <p>Inner class to output the twelve hour field.</p>
-     */
-    private static class TwelveHourField implements NumberRule {
-        private final NumberRule mRule;
-
-        /**
-         * Constructs an instance of <code>TwelveHourField</code> with the specified
-         * <code>NumberRule</code>.
-         * 
-         * @param rule the rule
-         */
-        TwelveHourField(NumberRule rule) {
-            mRule = rule;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return mRule.estimateLength();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            int value = calendar.get(Calendar.HOUR);
-            if (value == 0) {
-                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;
-            }
-            mRule.appendTo(buffer, value);
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, int value) {
-            mRule.appendTo(buffer, value);
-        }
-    }
-
-    /**
-     * <p>Inner class to output the twenty four hour field.</p>
-     */
-    private static class TwentyFourHourField implements NumberRule {
-        private final NumberRule mRule;
-
-        /**
-         * Constructs an instance of <code>TwentyFourHourField</code> with the specified
-         * <code>NumberRule</code>.
-         * 
-         * @param rule the rule
-         */
-        TwentyFourHourField(NumberRule rule) {
-            mRule = rule;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return mRule.estimateLength();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            int value = calendar.get(Calendar.HOUR_OF_DAY);
-            if (value == 0) {
-                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;
-            }
-            mRule.appendTo(buffer, value);
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, int value) {
-            mRule.appendTo(buffer, value);
-        }
-    }
-
-    /**
-     * <p>Inner class to output a time zone name.</p>
-     */
-    private static class TimeZoneNameRule implements Rule {
-        private final TimeZone mTimeZone;
-        private final boolean mTimeZoneForced;
-        private final Locale mLocale;
-        private final int mStyle;
-        private final String mStandard;
-        private final String mDaylight;
-
-        /**
-         * Constructs an instance of <code>TimeZoneNameRule</code> with the specified properties.
-         * 
-         * @param timeZone the time zone
-         * @param timeZoneForced if <code>true</code> the time zone is forced into standard and daylight
-         * @param locale the locale
-         * @param style the style
-         */
-        TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {
-            mTimeZone = timeZone;
-            mTimeZoneForced = timeZoneForced;
-            mLocale = locale;
-            mStyle = style;
-
-            if (timeZoneForced) {
-                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);
-                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);
-            } else {
-                mStandard = null;
-                mDaylight = null;
-            }
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            if (mTimeZoneForced) {
-                return Math.max(mStandard.length(), mDaylight.length());
-            } else if (mStyle == TimeZone.SHORT) {
-                return 4;
-            } else {
-                return 40;
-            }
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            if (mTimeZoneForced) {
-                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {
-                    buffer.append(mDaylight);
-                } else {
-                    buffer.append(mStandard);
-                }
-            } else {
-                TimeZone timeZone = calendar.getTimeZone();
-                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {
-                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));
-                } else {
-                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));
-                }
-            }
-        }
-    }
-
-    /**
-     * <p>Inner class to output a time zone as a number <code>+/-HHMM</code>
-     * or <code>+/-HH:MM</code>.</p>
-     */
-    private static class TimeZoneNumberRule implements Rule {
-        static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);
-        static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);
-        
-        final boolean mColon;
-        
-        /**
-         * Constructs an instance of <code>TimeZoneNumberRule</code> with the specified properties.
-         * 
-         * @param colon add colon between HH and MM in the output if <code>true</code>
-         */
-        TimeZoneNumberRule(boolean colon) {
-            mColon = colon;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int estimateLength() {
-            return 5;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public void appendTo(StringBuffer buffer, Calendar calendar) {
-            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
-            
-            if (offset < 0) {
-                buffer.append('-');
-                offset = -offset;
-            } else {
-                buffer.append('+');
-            }
-            
-            int hours = offset / (60 * 60 * 1000);
-            buffer.append((char)(hours / 10 + '0'));
-            buffer.append((char)(hours % 10 + '0'));
-            
-            if (mColon) {
-                buffer.append(':');
-            }
-            
-            int minutes = offset / (60 * 1000) - 60 * hours;
-            buffer.append((char)(minutes / 10 + '0'));
-            buffer.append((char)(minutes % 10 + '0'));
-        }            
-    }
-
-    // ----------------------------------------------------------------------
-    /**
-     * <p>Inner class that acts as a compound key for time zone names.</p>
-     */
-    private static class TimeZoneDisplayKey {
-        private final TimeZone mTimeZone;
-        private final int mStyle;
-        private final Locale mLocale;
-
-        /**
-         * Constructs an instance of <code>TimeZoneDisplayKey</code> with the specified properties.
-         *  
-         * @param timeZone the time zone
-         * @param daylight adjust the style for daylight saving time if <code>true</code>
-         * @param style the timezone style
-         * @param locale the timezone locale
-         */
-        TimeZoneDisplayKey(TimeZone timeZone,
-                           boolean daylight, int style, Locale locale) {
-            mTimeZone = timeZone;
-            if (daylight) {
-                style |= 0x80000000;
-            }
-            mStyle = style;
-            mLocale = locale;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int hashCode() {
-            return mStyle * 31 + mLocale.hashCode();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public boolean equals(Object obj) {
-            if (this == obj) {
-                return true;
-            }
-            if (obj instanceof TimeZoneDisplayKey) {
-                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;
-                return
-                    mTimeZone.equals(other.mTimeZone) &&
-                    mStyle == other.mStyle &&
-                    mLocale.equals(other.mLocale);
-            }
-            return false;
-        }
-    }
-
-    // ----------------------------------------------------------------------
-    /**
-     * <p>Helper class for creating compound objects.</p>
-     *
-     * <p>One use for this class is to create a hashtable key
-     * out of multiple objects.</p>
-     */
-    private static class Pair {
-        private final Object mObj1;
-        private final Object mObj2;
-
-        /**
-         * Constructs an instance of <code>Pair</code> to hold the specified objects.
-         * @param obj1 one object in the pair
-         * @param obj2 second object in the pair
-         */
-        public Pair(Object obj1, Object obj2) {
-            mObj1 = obj1;
-            mObj2 = obj2;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public boolean equals(Object obj) {
-            if (this == obj) {
-                return true;
-            }
-
-            if (!(obj instanceof Pair)) {
-                return false;
-            }
-
-            Pair key = (Pair)obj;
-
-            return
-                (mObj1 == null ?
-                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&
-                (mObj2 == null ?
-                 key.mObj2 == null : mObj2.equals(key.mObj2));
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public int hashCode() {
-            return
-                (mObj1 == null ? 0 : mObj1.hashCode()) +
-                (mObj2 == null ? 0 : mObj2.hashCode());
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public String toString() {
-            return "[" + mObj1 + ':' + mObj2 + ']';
-        }
-    }
-
-}
diff --git a/src/test/org/apache/commons/lang/AllLangTestSuite.java b/src/test/org/apache/commons/lang/AllLangTestSuite.java
index af07c1f7..f0f11624 100644
--- a/src/test/org/apache/commons/lang/AllLangTestSuite.java
+++ b/src/test/org/apache/commons/lang/AllLangTestSuite.java
@@ -60,7 +60,7 @@ public class AllLangTestSuite extends TestCase {
         suite.addTest(LangTestSuite.suite());
         suite.addTest(BuilderTestSuite.suite());
         suite.addTest(EnumTestSuite.suite());
-        suite.addTest(org.apache.commons.lang.enum.EnumTestSuite.suite());
+        suite.addTest(org.apache.commons.lang.enumeration.EnumTestSuite.suite());
         suite.addTest(ExceptionTestSuite.suite());
         suite.addTest(MathTestSuite.suite());
         suite.addTest(MutableTestSuite.suite());
diff --git a/src/test/org/apache/commons/lang/enum/Broken1Enum.java b/src/test/org/apache/commons/lang/enum/Broken1Enum.java
deleted file mode 100644
index 21203f0f..00000000
--- a/src/test/org/apache/commons/lang/enum/Broken1Enum.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Broken color enumeration.
- *
- * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a>
- * @version $Id$
- */
-public final class Broken1Enum extends Enum {
-    public static final Broken1Enum RED = new Broken1Enum("Red");
-    public static final Broken1Enum GREEN = new Broken1Enum("Green");
-    public static final Broken1Enum GREENISH = new Broken1Enum("Green");  // duplicate not allowed
-
-    private Broken1Enum(String color) {
-        super(color);
-    }
-
-    public static Broken1Enum getEnum(String color) {
-        return (Broken1Enum) getEnum(Broken1Enum.class, color);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(Broken1Enum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(Broken1Enum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(Broken1Enum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/Broken1OperationEnum.java b/src/test/org/apache/commons/lang/enum/Broken1OperationEnum.java
deleted file mode 100644
index 58c66f99..00000000
--- a/src/test/org/apache/commons/lang/enum/Broken1OperationEnum.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Broken Operator enumeration, null class.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-public abstract class Broken1OperationEnum extends Enum {
-    // This syntax works for JDK 1.3 and upwards:
-//    public static final OperationEnum PLUS = new OperationEnum("Plus") {
-//        public int eval(int a, int b) {
-//            return (a + b);
-//        }
-//    };
-//    public static final OperationEnum MINUS = new OperationEnum("Minus") {
-//        public int eval(int a, int b) {
-//            return (a - b);
-//        }
-//    };
-    // This syntax works for JDK 1.2 and upwards:
-    public static final Broken1OperationEnum PLUS = new PlusOperation();
-    private static class PlusOperation extends Broken1OperationEnum {
-        private PlusOperation() {
-            super("Plus");
-        }
-        public int eval(int a, int b) {
-            return (a + b);
-        }
-    }
-    public static final Broken1OperationEnum MINUS = new MinusOperation();
-    private static class MinusOperation extends Broken1OperationEnum {
-        private MinusOperation() {
-            super("Minus");
-        }
-        public int eval(int a, int b) {
-            return (a - b);
-        }
-    }
-
-    private Broken1OperationEnum(String name) {
-        super(name);
-    }
-    
-    public final Class getEnumClass() {
-        return null;
-    }
-
-    public abstract int eval(int a, int b);
-
-    public static Broken1OperationEnum getEnum(String name) {
-        return (Broken1OperationEnum) getEnum(Broken1OperationEnum.class, name);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(Broken1OperationEnum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(Broken1OperationEnum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(Broken1OperationEnum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/Broken2Enum.java b/src/test/org/apache/commons/lang/enum/Broken2Enum.java
deleted file mode 100644
index 246659f2..00000000
--- a/src/test/org/apache/commons/lang/enum/Broken2Enum.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Broken color enumeration.
- *
- * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a>
- * @version $Id$
- */
-public final class Broken2Enum extends Enum {
-    public static final Broken2Enum RED = new Broken2Enum("Red");
-    public static final Broken2Enum GREEN = new Broken2Enum("Green");
-    public static final Broken2Enum BLUE = new Broken2Enum("");  // blank not allowed
-
-    private Broken2Enum(String color) {
-        super(color);
-    }
-
-    public static Broken2Enum getEnum(String color) {
-        return (Broken2Enum) getEnum(Broken2Enum.class, color);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(Broken2Enum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(Broken2Enum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(Broken2Enum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/Broken2OperationEnum.java b/src/test/org/apache/commons/lang/enum/Broken2OperationEnum.java
deleted file mode 100644
index d2eb5176..00000000
--- a/src/test/org/apache/commons/lang/enum/Broken2OperationEnum.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Broken Operator enumeration, getEnumClass() not superclass.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-public abstract class Broken2OperationEnum extends Enum {
-    // This syntax works for JDK 1.3 and upwards:
-//    public static final OperationEnum PLUS = new OperationEnum("Plus") {
-//        public int eval(int a, int b) {
-//            return (a + b);
-//        }
-//    };
-//    public static final OperationEnum MINUS = new OperationEnum("Minus") {
-//        public int eval(int a, int b) {
-//            return (a - b);
-//        }
-//    };
-    // This syntax works for JDK 1.2 and upwards:
-    public static final Broken2OperationEnum PLUS = new PlusOperation();
-    private static class PlusOperation extends Broken2OperationEnum {
-        private PlusOperation() {
-            super("Plus");
-        }
-        public int eval(int a, int b) {
-            return (a + b);
-        }
-    }
-    public static final Broken2OperationEnum MINUS = new MinusOperation();
-    private static class MinusOperation extends Broken2OperationEnum {
-        private MinusOperation() {
-            super("Minus");
-        }
-        public int eval(int a, int b) {
-            return (a - b);
-        }
-    }
-
-    private Broken2OperationEnum(String name) {
-        super(name);
-    }
-    
-    public final Class getEnumClass() {
-        return ColorEnum.class;
-    }
-
-    public abstract int eval(int a, int b);
-
-    public static Broken2OperationEnum getEnum(String name) {
-        return (Broken2OperationEnum) getEnum(Broken2OperationEnum.class, name);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(Broken2OperationEnum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(Broken2OperationEnum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(Broken2OperationEnum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/Broken3Enum.java b/src/test/org/apache/commons/lang/enum/Broken3Enum.java
deleted file mode 100644
index 84e97378..00000000
--- a/src/test/org/apache/commons/lang/enum/Broken3Enum.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Broken color enumeration.
- *
- * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a>
- * @version $Id$
- */
-public final class Broken3Enum extends Enum {
-    public static final Broken3Enum RED = new Broken3Enum("Red");
-    public static final Broken3Enum GREEN = new Broken3Enum("Green");
-    public static final Broken3Enum BLUE = new Broken3Enum(null);  // null not allowed
-
-    private Broken3Enum(String color) {
-        super(color);
-    }
-
-    public static Broken3Enum getEnum(String color) {
-        return (Broken3Enum) getEnum(Broken3Enum.class, color);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(Broken3Enum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(Broken3Enum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(Broken3Enum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/Broken3OperationEnum.java b/src/test/org/apache/commons/lang/enum/Broken3OperationEnum.java
deleted file mode 100644
index b577abd5..00000000
--- a/src/test/org/apache/commons/lang/enum/Broken3OperationEnum.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Broken Operator enumeration, getEnumClass() is Enum.class.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-public abstract class Broken3OperationEnum extends Enum {
-    // This syntax works for JDK 1.3 and upwards:
-//    public static final OperationEnum PLUS = new OperationEnum("Plus") {
-//        public int eval(int a, int b) {
-//            return (a + b);
-//        }
-//    };
-//    public static final OperationEnum MINUS = new OperationEnum("Minus") {
-//        public int eval(int a, int b) {
-//            return (a - b);
-//        }
-//    };
-    // This syntax works for JDK 1.2 and upwards:
-    public static final Broken3OperationEnum PLUS = new PlusOperation();
-    private static class PlusOperation extends Broken3OperationEnum {
-        private PlusOperation() {
-            super("Plus");
-        }
-        public int eval(int a, int b) {
-            return (a + b);
-        }
-    }
-    public static final Broken3OperationEnum MINUS = new MinusOperation();
-    private static class MinusOperation extends Broken3OperationEnum {
-        private MinusOperation() {
-            super("Minus");
-        }
-        public int eval(int a, int b) {
-            return (a - b);
-        }
-    }
-
-    private Broken3OperationEnum(String name) {
-        super(name);
-    }
-    
-    public final Class getEnumClass() {
-        return Enum.class;
-    }
-
-    public abstract int eval(int a, int b);
-
-    public static Broken3OperationEnum getEnum(String name) {
-        return (Broken3OperationEnum) getEnum(Broken3OperationEnum.class, name);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(Broken3OperationEnum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(Broken3OperationEnum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(Broken3OperationEnum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/Broken4OperationEnum.java b/src/test/org/apache/commons/lang/enum/Broken4OperationEnum.java
deleted file mode 100644
index 9d622096..00000000
--- a/src/test/org/apache/commons/lang/enum/Broken4OperationEnum.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Broken Operator enumeration, getEnumClass() is ValuedEnum.class.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-public abstract class Broken4OperationEnum extends Enum {
-    // This syntax works for JDK 1.3 and upwards:
-//    public static final OperationEnum PLUS = new OperationEnum("Plus") {
-//        public int eval(int a, int b) {
-//            return (a + b);
-//        }
-//    };
-//    public static final OperationEnum MINUS = new OperationEnum("Minus") {
-//        public int eval(int a, int b) {
-//            return (a - b);
-//        }
-//    };
-    // This syntax works for JDK 1.2 and upwards:
-    public static final Broken4OperationEnum PLUS = new PlusOperation();
-    private static class PlusOperation extends Broken4OperationEnum {
-        private PlusOperation() {
-            super("Plus");
-        }
-        public int eval(int a, int b) {
-            return (a + b);
-        }
-    }
-    public static final Broken4OperationEnum MINUS = new MinusOperation();
-    private static class MinusOperation extends Broken4OperationEnum {
-        private MinusOperation() {
-            super("Minus");
-        }
-        public int eval(int a, int b) {
-            return (a - b);
-        }
-    }
-
-    private Broken4OperationEnum(String name) {
-        super(name);
-    }
-    
-    public final Class getEnumClass() {
-        return ValuedEnum.class;
-    }
-
-    public abstract int eval(int a, int b);
-
-    public static Broken4OperationEnum getEnum(String name) {
-        return (Broken4OperationEnum) getEnum(Broken4OperationEnum.class, name);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(Broken4OperationEnum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(Broken4OperationEnum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(Broken4OperationEnum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/Broken5OperationEnum.java b/src/test/org/apache/commons/lang/enum/Broken5OperationEnum.java
deleted file mode 100644
index 7f7f698c..00000000
--- a/src/test/org/apache/commons/lang/enum/Broken5OperationEnum.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Broken Operator enumeration, getEnumClass() is not an Enum class.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-public abstract class Broken5OperationEnum extends Enum {
-    // This syntax works for JDK 1.3 and upwards:
-//    public static final OperationEnum PLUS = new OperationEnum("Plus") {
-//        public int eval(int a, int b) {
-//            return (a + b);
-//        }
-//    };
-//    public static final OperationEnum MINUS = new OperationEnum("Minus") {
-//        public int eval(int a, int b) {
-//            return (a - b);
-//        }
-//    };
-    // This syntax works for JDK 1.2 and upwards:
-    public static final Broken5OperationEnum PLUS = new PlusOperation();
-    private static class PlusOperation extends Broken5OperationEnum {
-        private PlusOperation() {
-            super("Plus");
-        }
-        public int eval(int a, int b) {
-            return (a + b);
-        }
-    }
-    public static final Broken5OperationEnum MINUS = new MinusOperation();
-    private static class MinusOperation extends Broken5OperationEnum {
-        private MinusOperation() {
-            super("Minus");
-        }
-        public int eval(int a, int b) {
-            return (a - b);
-        }
-    }
-
-    private Broken5OperationEnum(String name) {
-        super(name);
-    }
-    
-    public final Class getEnumClass() {
-        return String.class;
-    }
-
-    public abstract int eval(int a, int b);
-
-    public static Broken5OperationEnum getEnum(String name) {
-        return (Broken5OperationEnum) getEnum(Broken5OperationEnum.class, name);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(Broken5OperationEnum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(Broken5OperationEnum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(Broken5OperationEnum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/ColorEnum.java b/src/test/org/apache/commons/lang/enum/ColorEnum.java
deleted file mode 100644
index 0107ea9a..00000000
--- a/src/test/org/apache/commons/lang/enum/ColorEnum.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Color enumeration.
- *
- * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a>
- * @version $Id$
- */
-
-public final class ColorEnum extends Enum {
-    public static final ColorEnum RED = new ColorEnum("Red");
-    public static final ColorEnum GREEN = new ColorEnum("Green");
-    public static final ColorEnum BLUE = new ColorEnum("Blue");
-
-    private ColorEnum(String color) {
-        super(color);
-    }
-
-    public static ColorEnum getEnum(String color) {
-        return (ColorEnum) getEnum(ColorEnum.class, color);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(ColorEnum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(ColorEnum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(ColorEnum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/DummyEnum.java b/src/test/org/apache/commons/lang/enum/DummyEnum.java
deleted file mode 100644
index cc144025..00000000
--- a/src/test/org/apache/commons/lang/enum/DummyEnum.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-/**
- * Dummy enumeration - no values.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-public abstract class DummyEnum extends Enum {
-
-    private DummyEnum(String name) {
-        super(name);
-    }
-
-}
diff --git a/src/test/org/apache/commons/lang/enum/EnumTest.java b/src/test/org/apache/commons/lang/enum/EnumTest.java
deleted file mode 100644
index 9ca9bb92..00000000
--- a/src/test/org/apache/commons/lang/enum/EnumTest.java
+++ /dev/null
@@ -1,556 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.lang.enum;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestCase;
-import junit.framework.TestSuite;
-
-import org.apache.commons.lang.SerializationUtils;
-
-/**
- * Test cases for the {@link Enum} class.
- * 
- * @author Stephen Colebourne
- * @author Gary D. Gregory
- * @version $Id$
- */
-
-public final class EnumTest extends TestCase {
-
-    private static final String ENUM_CLASS_NAME = "org.apache.commons.lang.enum.ColorEnum";
-
-    public EnumTest(String name) {
-        super(name);
-    }
-
-    public void setUp() {
-    }
-
-    public static Test suite() {
-        TestSuite suite = new TestSuite(EnumTest.class);
-        suite.setName("Enum Tests");
-        return suite;
-    }
-
-    public void testName() {
-        assertEquals("Red", ColorEnum.RED.getName());
-        assertEquals("Green", ColorEnum.GREEN.getName());
-        assertEquals("Blue", ColorEnum.BLUE.getName());
-    }
-
-    public void testCompareTo() {
-        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.BLUE) == 0);
-        assertTrue(ColorEnum.RED.compareTo(ColorEnum.BLUE) > 0);
-        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.RED) < 0);
-        try {
-            ColorEnum.RED.compareTo(null);
-            fail();
-        } catch (NullPointerException ex) {
-        }
-        try {
-            ColorEnum.RED.compareTo(new Object());
-            fail();
-        } catch (ClassCastException ex) {
-        }
-    }
-
-    public void testEquals() {
-        assertSame(ColorEnum.RED, ColorEnum.RED);
-        assertSame(ColorEnum.getEnum("Red"), ColorEnum.RED);
-        assertEquals(false, ColorEnum.RED.equals(null));
-        assertEquals(true, ColorEnum.RED.equals(ColorEnum.RED));
-        assertEquals(true, ColorEnum.RED.equals(ColorEnum.getEnum("Red")));
-    }
-
-    public void testHashCode() {
-        assertEquals(ColorEnum.RED.hashCode(), ColorEnum.RED.hashCode());
-        assertEquals(7 + ColorEnum.class.hashCode() + 3 * "Red".hashCode(), ColorEnum.RED.hashCode());
-    }
-
-    public void testToString() {
-        String toString = ColorEnum.RED.toString();
-        assertEquals("ColorEnum[Red]", toString);
-        assertSame(toString, ColorEnum.RED.toString());
-    }
-
-    public void testIterator() {
-        Iterator it = ColorEnum.iterator();
-        assertSame(ColorEnum.RED, it.next());
-        assertSame(ColorEnum.GREEN, it.next());
-        assertSame(ColorEnum.BLUE, it.next());
-    }
-
-    public void testList() {
-        List list = new ArrayList(ColorEnum.getEnumList());
-
-        assertNotNull(list);
-
-        assertEquals(list.size(), ColorEnum.getEnumMap().keySet().size());
-
-        Iterator it = list.iterator();
-        assertSame(ColorEnum.RED, it.next());
-        assertSame(ColorEnum.GREEN, it.next());
-        assertSame(ColorEnum.BLUE, it.next());
-    }
-
-    public void testMap() {
-        Map map = new HashMap(ColorEnum.getEnumMap());
-
-        assertNotNull(map);
-        assertTrue(map.containsValue(ColorEnum.RED));
-        assertTrue(map.containsValue(ColorEnum.GREEN));
-        assertTrue(map.containsValue(ColorEnum.BLUE));
-        assertSame(ColorEnum.RED, map.get("Red"));
-        assertSame(ColorEnum.GREEN, map.get("Green"));
-        assertSame(ColorEnum.BLUE, map.get("Blue"));
-        assertEquals(map.keySet().size(), ColorEnum.getEnumList().size());
-    }
-
-    public void testGet() {
-        assertSame(ColorEnum.RED, ColorEnum.getEnum("Red"));
-        assertSame(ColorEnum.GREEN, ColorEnum.getEnum("Green"));
-        assertSame(ColorEnum.BLUE, ColorEnum.getEnum("Blue"));
-        assertSame(null, ColorEnum.getEnum("Pink"));
-    }
-
-    public void testSerialization() {
-        int hashCode = ColorEnum.RED.hashCode();
-        assertSame(ColorEnum.RED, SerializationUtils.clone(ColorEnum.RED));
-        assertEquals(hashCode, SerializationUtils.clone(ColorEnum.RED).hashCode());
-        assertSame(ColorEnum.GREEN, SerializationUtils.clone(ColorEnum.GREEN));
-        assertSame(ColorEnum.BLUE, SerializationUtils.clone(ColorEnum.BLUE));
-    }
-
-    public void testBroken1() {
-        try {
-            Broken1Enum.RED.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken2() {
-        try {
-            Broken2Enum.RED.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken3() {
-        try {
-            Broken3Enum.RED.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken1Operation() {
-        try {
-            Broken1OperationEnum.PLUS.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken2Operation() {
-        try {
-            Broken2OperationEnum.PLUS.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken3Operation() {
-        try {
-            Broken3OperationEnum.PLUS.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken4Operation() {
-        try {
-            Broken4OperationEnum.PLUS.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken5Operation() {
-        try {
-            Broken5OperationEnum.PLUS.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testOperationGet() {
-        assertSame(OperationEnum.PLUS, OperationEnum.getEnum("Plus"));
-        assertSame(OperationEnum.MINUS, OperationEnum.getEnum("Minus"));
-        assertSame(null, OperationEnum.getEnum("Pink"));
-    }
-
-    public void testOperationSerialization() {
-        assertSame(OperationEnum.PLUS, SerializationUtils.clone(OperationEnum.PLUS));
-        assertSame(OperationEnum.MINUS, SerializationUtils.clone(OperationEnum.MINUS));
-    }
-
-    public void testOperationToString() {
-        assertEquals("OperationEnum[Plus]", OperationEnum.PLUS.toString());
-    }
-
-    public void testOperationList() {
-        List list = OperationEnum.getEnumList();
-        assertNotNull(list);
-        assertEquals(2, list.size());
-        assertEquals(list.size(), OperationEnum.getEnumMap().keySet().size());
-
-        Iterator it = list.iterator();
-        assertSame(OperationEnum.PLUS, it.next());
-        assertSame(OperationEnum.MINUS, it.next());
-    }
-
-    public void testOperationMap() {
-        Map map = OperationEnum.getEnumMap();
-        assertNotNull(map);
-        assertEquals(map.keySet().size(), OperationEnum.getEnumList().size());
-
-        assertTrue(map.containsValue(OperationEnum.PLUS));
-        assertTrue(map.containsValue(OperationEnum.MINUS));
-        assertSame(OperationEnum.PLUS, map.get("Plus"));
-        assertSame(OperationEnum.MINUS, map.get("Minus"));
-    }
-
-    public void testOperationCalculation() {
-        assertEquals(3, OperationEnum.PLUS.eval(1, 2));
-        assertEquals(-1, OperationEnum.MINUS.eval(1, 2));
-    }
-
-    // -----------------------------------------------------------------------
-    public void testExtended1Get() {
-        assertSame(Extended1Enum.ALPHA, Extended1Enum.getEnum("Alpha"));
-        assertSame(Extended1Enum.BETA, Extended1Enum.getEnum("Beta"));
-        assertSame(null, Extended1Enum.getEnum("Gamma"));
-        assertSame(null, Extended1Enum.getEnum("Delta"));
-    }
-
-    public void testExtended2Get() {
-        assertSame(Extended1Enum.ALPHA, Extended2Enum.ALPHA);
-        assertSame(Extended1Enum.BETA, Extended2Enum.BETA);
-
-        assertSame(Extended2Enum.ALPHA, Extended2Enum.getEnum("Alpha"));
-        assertSame(Extended2Enum.BETA, Extended2Enum.getEnum("Beta"));
-        assertSame(Extended2Enum.GAMMA, Extended2Enum.getEnum("Gamma"));
-        assertSame(null, Extended2Enum.getEnum("Delta"));
-    }
-
-    public void testExtended3Get() {
-        assertSame(Extended2Enum.ALPHA, Extended3Enum.ALPHA);
-        assertSame(Extended2Enum.BETA, Extended3Enum.BETA);
-        assertSame(Extended2Enum.GAMMA, Extended3Enum.GAMMA);
-
-        assertSame(Extended3Enum.ALPHA, Extended3Enum.getEnum("Alpha"));
-        assertSame(Extended3Enum.BETA, Extended3Enum.getEnum("Beta"));
-        assertSame(Extended3Enum.GAMMA, Extended3Enum.getEnum("Gamma"));
-        assertSame(Extended3Enum.DELTA, Extended3Enum.getEnum("Delta"));
-    }
-
-    public void testExtendedSerialization() {
-        assertSame(Extended1Enum.ALPHA, SerializationUtils.clone(Extended1Enum.ALPHA));
-        assertSame(Extended1Enum.BETA, SerializationUtils.clone(Extended1Enum.BETA));
-        assertSame(Extended2Enum.GAMMA, SerializationUtils.clone(Extended2Enum.GAMMA));
-        assertSame(Extended3Enum.DELTA, SerializationUtils.clone(Extended3Enum.DELTA));
-    }
-
-    public void testExtendedToString() {
-        assertEquals("Extended1Enum[Alpha]", Extended1Enum.ALPHA.toString());
-        assertEquals("Extended1Enum[Beta]", Extended1Enum.BETA.toString());
-
-        assertEquals("Extended1Enum[Alpha]", Extended2Enum.ALPHA.toString());
-        assertEquals("Extended1Enum[Beta]", Extended2Enum.BETA.toString());
-        assertEquals("Extended2Enum[Gamma]", Extended2Enum.GAMMA.toString());
-
-        assertEquals("Extended1Enum[Alpha]", Extended3Enum.ALPHA.toString());
-        assertEquals("Extended1Enum[Beta]", Extended3Enum.BETA.toString());
-        assertEquals("Extended2Enum[Gamma]", Extended3Enum.GAMMA.toString());
-        assertEquals("Extended3Enum[Delta]", Extended3Enum.DELTA.toString());
-    }
-
-    public void testExtended1List() {
-        List list = Extended1Enum.getEnumList();
-        assertNotNull(list);
-        assertEquals(2, list.size());
-        assertEquals(list.size(), Extended1Enum.getEnumMap().keySet().size());
-
-        Iterator it = list.iterator();
-        assertSame(Extended1Enum.ALPHA, it.next());
-        assertSame(Extended1Enum.BETA, it.next());
-    }
-
-    public void testExtended2List() {
-        List list = Extended2Enum.getEnumList();
-        assertNotNull(list);
-        assertEquals(3, list.size());
-        assertEquals(list.size(), Extended2Enum.getEnumMap().keySet().size());
-
-        Iterator it = list.iterator();
-        assertSame(Extended2Enum.ALPHA, it.next());
-        assertSame(Extended2Enum.BETA, it.next());
-        assertSame(Extended2Enum.GAMMA, it.next());
-    }
-
-    public void testExtended3List() {
-        List list = Extended3Enum.getEnumList();
-        assertNotNull(list);
-        assertEquals(4, list.size());
-        assertEquals(list.size(), Extended3Enum.getEnumMap().keySet().size());
-
-        Iterator it = list.iterator();
-        assertSame(Extended3Enum.ALPHA, it.next());
-        assertSame(Extended3Enum.BETA, it.next());
-        assertSame(Extended3Enum.GAMMA, it.next());
-        assertSame(Extended3Enum.DELTA, it.next());
-    }
-
-    public void testExtended1Map() {
-        Map map = Extended1Enum.getEnumMap();
-        assertNotNull(map);
-        assertEquals(map.keySet().size(), Extended1Enum.getEnumList().size());
-
-        assertTrue(map.containsValue(Extended1Enum.ALPHA));
-        assertTrue(map.containsValue(Extended1Enum.BETA));
-        assertSame(Extended1Enum.ALPHA, map.get("Alpha"));
-        assertSame(Extended1Enum.BETA, map.get("Beta"));
-    }
-
-    public void testExtended2Map() {
-        Map map = Extended2Enum.getEnumMap();
-        assertNotNull(map);
-        assertEquals(map.keySet().size(), Extended2Enum.getEnumList().size());
-
-        assertTrue(map.containsValue(Extended2Enum.ALPHA));
-        assertTrue(map.containsValue(Extended2Enum.BETA));
-        assertTrue(map.containsValue(Extended2Enum.GAMMA));
-        assertSame(Extended2Enum.ALPHA, map.get("Alpha"));
-        assertSame(Extended2Enum.BETA, map.get("Beta"));
-        assertSame(Extended2Enum.GAMMA, map.get("Gamma"));
-    }
-
-    public void testExtended3Map() {
-        Map map = Extended3Enum.getEnumMap();
-        assertNotNull(map);
-        assertEquals(map.keySet().size(), Extended3Enum.getEnumList().size());
-
-        assertTrue(map.containsValue(Extended3Enum.ALPHA));
-        assertTrue(map.containsValue(Extended3Enum.BETA));
-        assertTrue(map.containsValue(Extended3Enum.GAMMA));
-        assertTrue(map.containsValue(Extended3Enum.DELTA));
-        assertSame(Extended3Enum.ALPHA, map.get("Alpha"));
-        assertSame(Extended3Enum.BETA, map.get("Beta"));
-        assertSame(Extended3Enum.GAMMA, map.get("Gamma"));
-        assertSame(Extended3Enum.DELTA, map.get("Delta"));
-    }
-
-    // -----------------------------------------------------------------------
-    public void testNested() {
-        List list = new ArrayList(Nest.ColorEnum.getEnumList());
-        assertEquals(3, list.size()); // all is well
-        Iterator it = list.iterator();
-        assertSame(Nest.ColorEnum.RED, it.next());
-        assertSame(Nest.ColorEnum.GREEN, it.next());
-        assertSame(Nest.ColorEnum.BLUE, it.next());
-        // This nesting works because the enum constants are defined in the SAME
-        // class as the getEnumList(). It just acts as a normal enum.
-    }
-
-    public void testNestedBroken() {
-        List list = new ArrayList(NestBroken.ColorEnum.getEnumList());
-        try {
-            assertEquals(0, list.size()); // no enums!!!
-            // this is BROKEN because the enum constants are defined in a DIFFERENT
-            // class from getEnumList(). Once NestBroken class is referenced,
-            // and thus class loaded with its enum constants, the getEnumList works:
-        } catch (AssertionFailedError ex) {
-            // this actually works and isn't broken on Linux SunJDK1.4.1, so...
-            assertEquals(3, list.size());
-        }
-        new NestBroken();
-        list = new ArrayList(NestBroken.ColorEnum.getEnumList());
-        assertEquals(3, list.size()); // all is well!!!
-        Iterator it = list.iterator();
-        assertSame(NestBroken.RED, it.next());
-        assertSame(NestBroken.GREEN, it.next());
-        assertSame(NestBroken.BLUE, it.next());
-    }
-
-    public void testNestedLinked() {
-        List list = new ArrayList(NestLinked.ColorEnum.getEnumList());
-        assertEquals(3, list.size()); // all is well
-        Iterator it = list.iterator();
-        assertSame(NestLinked.RED, it.next());
-        assertSame(NestLinked.GREEN, it.next());
-        assertSame(NestLinked.BLUE, it.next());
-        // This nesting works because a static block in the enum class forces a
-        // class load of the outer class which defines the enum constants.
-    }
-
-    public void testNestedReferenced() {
-        List list = new ArrayList(NestReferenced.ColorEnum.getEnumList());
-        assertEquals(3, list.size()); // all is well
-        Iterator it = list.iterator();
-        assertSame(NestReferenced.RED, it.next());
-        assertSame(NestReferenced.GREEN, it.next());
-        assertSame(NestReferenced.BLUE, it.next());
-        // This nesting works because the enum constants are actually defined in
-        // the SAME class as the getEnumList(). The references in the outer class
-        // are just extra references.
-    }
-
-    public void testColorEnumEqualsWithDifferentClassLoaders() {}
-// Defects4J: flaky method
-//     public void testColorEnumEqualsWithDifferentClassLoaders() throws SecurityException, IllegalArgumentException,
-//             ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
-//         this.testWithDifferentClassLoaders(ColorEnum.BLUE);
-//         this.testWithDifferentClassLoaders(ColorEnum.GREEN);
-//         this.testWithDifferentClassLoaders(ColorEnum.RED);
-//     }
-
-    void testWithDifferentClassLoaders(ColorEnum colorEnum) throws ClassNotFoundException, SecurityException,
-            NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
-        // Sanity checks:
-        assertTrue(colorEnum.equals(colorEnum));
-        assertNotNull(ColorEnum.class.getClassLoader());
-        // set up:
-        ClassLoader myClassLoader = EnumTest.class.getClassLoader();
-        if (!(myClassLoader instanceof URLClassLoader)) {
-            fail("EnumTest ClassLoader = " + (myClassLoader == null ? null : myClassLoader.getClass().getName()));
-        }
-        ClassLoader classLoader = URLClassLoader.newInstance( ((URLClassLoader)myClassLoader).getURLs(), null);
-        Object enumObjectFromOtherClassLoader = this.getColorEnum(classLoader, colorEnum.getName());
-
-        // the real test, part 1.
-        try {
-            ColorEnum testCase = (ColorEnum) enumObjectFromOtherClassLoader;
-            fail("Should have thrown a ClassCastException for " + testCase);
-        } catch (ClassCastException e) {
-            // normal.
-        }
-
-        // the real test, part 2.
-        assertEquals("The two objects should match even though they are from different class loaders", colorEnum,
-                enumObjectFromOtherClassLoader);
-
-        // the real test, part 3 - testing equals(Object)
-        int falseCount = 0;
-        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {
-            ColorEnum element = (ColorEnum) iter.next();
-            if (!colorEnum.equals(element)) {
-                falseCount++;
-                assertFalse(enumObjectFromOtherClassLoader.equals(element));
-            }
-        }
-        assertEquals(ColorEnum.getEnumList().size() - 1, falseCount);
-
-        // the real test, part 4 - testing compareTo(Object) == 0
-        falseCount = 0;
-        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {
-            ColorEnum element = (ColorEnum) iter.next();
-            if (!colorEnum.equals(element)) {
-                falseCount++;
-                assertFalse( ((Comparable)enumObjectFromOtherClassLoader).compareTo(element) == 0);
-            }
-        }
-        assertEquals(ColorEnum.getEnumList().size() - 1, falseCount);
-    }
-
-    Object getColorEnum(ClassLoader classLoader, String color) throws ClassNotFoundException, SecurityException,
-            NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
-        // Sanity check:
-        ColorEnum.RED.equals(ColorEnum.RED);
-        assertNotNull(ColorEnum.class.getClassLoader());
-        // set up:
-        assertNotNull(classLoader);
-        assertFalse(classLoader.equals(ColorEnum.class.getClassLoader()));
-        Class otherColorEnumClass = null;
-        try {
-            otherColorEnumClass = classLoader.loadClass(ENUM_CLASS_NAME);
-        } catch (ClassNotFoundException e) {
-            // Dump some information to help debug class loader issues under different JREs, Ant, Eclipse.
-            System.err.println("Could not load " + ENUM_CLASS_NAME + " from the class loader " + classLoader);
-            URLClassLoader urlCl = (URLClassLoader) classLoader;
-            URL[] urls = urlCl.getURLs();
-            System.err.println("Class loader has " + urls.length + " URLs:");
-            for (int i = 0; i < urls.length; i++) {
-                System.err.println("URL[" + i + "] = " + urls[i]);
-            }
-            e.printStackTrace();
-            throw e;
-        }
-        assertNotNull(otherColorEnumClass);
-        assertNotNull(otherColorEnumClass.getClassLoader());
-        assertTrue(classLoader.equals(otherColorEnumClass.getClassLoader()));
-        assertFalse(otherColorEnumClass.getClassLoader().equals(ColorEnum.class.getClassLoader()));
-        Method method = otherColorEnumClass.getMethod("getEnum", new Class[]{String.class});
-        Object enumObject = method.invoke(otherColorEnumClass, new Object[]{color});
-        assertNotNull(enumObject);
-        assertFalse(ColorEnum.class.equals(enumObject.getClass()));
-        assertFalse(ColorEnum.class == enumObject.getClass());
-        return enumObject;
-    }
-
-    public void testEqualsToWrongInstance() {
-        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {
-            ColorEnum element = (ColorEnum) iter.next();
-            this.testEqualsToWrongInstance(element);
-        }
-    }
-
-    void testEqualsToWrongInstance(ColorEnum colorEnum) {
-        assertEquals(false, colorEnum.equals("test"));
-        assertEquals(false, colorEnum.equals(new Integer(1)));
-        assertEquals(false, colorEnum.equals(new Boolean(true)));
-        assertEquals(false, colorEnum.equals(new StringBuffer("test")));
-        assertEquals(false, colorEnum.equals(new Object()));
-        assertEquals(false, colorEnum.equals(null));
-        assertEquals(false, colorEnum.equals(""));
-        assertEquals(false, colorEnum.equals(ColorEnum.getEnum(null)));
-        assertEquals(false, colorEnum.equals(ColorEnum.getEnum("")));
-        assertEquals(false, colorEnum.equals(ColorEnum.getEnum("This ColorEnum does not exist.")));
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/EnumTest.java.bak b/src/test/org/apache/commons/lang/enum/EnumTest.java.bak
deleted file mode 100644
index 823b5d08..00000000
--- a/src/test/org/apache/commons/lang/enum/EnumTest.java.bak
+++ /dev/null
@@ -1,554 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.lang.enum;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import junit.framework.AssertionFailedError;
-import junit.framework.Test;
-import junit.framework.TestCase;
-import junit.framework.TestSuite;
-
-import org.apache.commons.lang.SerializationUtils;
-
-/**
- * Test cases for the {@link Enum} class.
- * 
- * @author Stephen Colebourne
- * @author Gary D. Gregory
- * @version $Id$
- */
-
-public final class EnumTest extends TestCase {
-
-    private static final String ENUM_CLASS_NAME = "org.apache.commons.lang.enum.ColorEnum";
-
-    public EnumTest(String name) {
-        super(name);
-    }
-
-    public void setUp() {
-    }
-
-    public static Test suite() {
-        TestSuite suite = new TestSuite(EnumTest.class);
-        suite.setName("Enum Tests");
-        return suite;
-    }
-
-    public void testName() {
-        assertEquals("Red", ColorEnum.RED.getName());
-        assertEquals("Green", ColorEnum.GREEN.getName());
-        assertEquals("Blue", ColorEnum.BLUE.getName());
-    }
-
-    public void testCompareTo() {
-        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.BLUE) == 0);
-        assertTrue(ColorEnum.RED.compareTo(ColorEnum.BLUE) > 0);
-        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.RED) < 0);
-        try {
-            ColorEnum.RED.compareTo(null);
-            fail();
-        } catch (NullPointerException ex) {
-        }
-        try {
-            ColorEnum.RED.compareTo(new Object());
-            fail();
-        } catch (ClassCastException ex) {
-        }
-    }
-
-    public void testEquals() {
-        assertSame(ColorEnum.RED, ColorEnum.RED);
-        assertSame(ColorEnum.getEnum("Red"), ColorEnum.RED);
-        assertEquals(false, ColorEnum.RED.equals(null));
-        assertEquals(true, ColorEnum.RED.equals(ColorEnum.RED));
-        assertEquals(true, ColorEnum.RED.equals(ColorEnum.getEnum("Red")));
-    }
-
-    public void testHashCode() {
-        assertEquals(ColorEnum.RED.hashCode(), ColorEnum.RED.hashCode());
-        assertEquals(7 + ColorEnum.class.hashCode() + 3 * "Red".hashCode(), ColorEnum.RED.hashCode());
-    }
-
-    public void testToString() {
-        String toString = ColorEnum.RED.toString();
-        assertEquals("ColorEnum[Red]", toString);
-        assertSame(toString, ColorEnum.RED.toString());
-    }
-
-    public void testIterator() {
-        Iterator it = ColorEnum.iterator();
-        assertSame(ColorEnum.RED, it.next());
-        assertSame(ColorEnum.GREEN, it.next());
-        assertSame(ColorEnum.BLUE, it.next());
-    }
-
-    public void testList() {
-        List list = new ArrayList(ColorEnum.getEnumList());
-
-        assertNotNull(list);
-
-        assertEquals(list.size(), ColorEnum.getEnumMap().keySet().size());
-
-        Iterator it = list.iterator();
-        assertSame(ColorEnum.RED, it.next());
-        assertSame(ColorEnum.GREEN, it.next());
-        assertSame(ColorEnum.BLUE, it.next());
-    }
-
-    public void testMap() {
-        Map map = new HashMap(ColorEnum.getEnumMap());
-
-        assertNotNull(map);
-        assertTrue(map.containsValue(ColorEnum.RED));
-        assertTrue(map.containsValue(ColorEnum.GREEN));
-        assertTrue(map.containsValue(ColorEnum.BLUE));
-        assertSame(ColorEnum.RED, map.get("Red"));
-        assertSame(ColorEnum.GREEN, map.get("Green"));
-        assertSame(ColorEnum.BLUE, map.get("Blue"));
-        assertEquals(map.keySet().size(), ColorEnum.getEnumList().size());
-    }
-
-    public void testGet() {
-        assertSame(ColorEnum.RED, ColorEnum.getEnum("Red"));
-        assertSame(ColorEnum.GREEN, ColorEnum.getEnum("Green"));
-        assertSame(ColorEnum.BLUE, ColorEnum.getEnum("Blue"));
-        assertSame(null, ColorEnum.getEnum("Pink"));
-    }
-
-    public void testSerialization() {
-        int hashCode = ColorEnum.RED.hashCode();
-        assertSame(ColorEnum.RED, SerializationUtils.clone(ColorEnum.RED));
-        assertEquals(hashCode, SerializationUtils.clone(ColorEnum.RED).hashCode());
-        assertSame(ColorEnum.GREEN, SerializationUtils.clone(ColorEnum.GREEN));
-        assertSame(ColorEnum.BLUE, SerializationUtils.clone(ColorEnum.BLUE));
-    }
-
-    public void testBroken1() {
-        try {
-            Broken1Enum.RED.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken2() {
-        try {
-            Broken2Enum.RED.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken3() {
-        try {
-            Broken3Enum.RED.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken1Operation() {
-        try {
-            Broken1OperationEnum.PLUS.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken2Operation() {
-        try {
-            Broken2OperationEnum.PLUS.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken3Operation() {
-        try {
-            Broken3OperationEnum.PLUS.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken4Operation() {
-        try {
-            Broken4OperationEnum.PLUS.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testBroken5Operation() {
-        try {
-            Broken5OperationEnum.PLUS.getName();
-            fail();
-        } catch (ExceptionInInitializerError ex) {
-            assertTrue(ex.getException() instanceof IllegalArgumentException);
-        }
-    }
-
-    public void testOperationGet() {
-        assertSame(OperationEnum.PLUS, OperationEnum.getEnum("Plus"));
-        assertSame(OperationEnum.MINUS, OperationEnum.getEnum("Minus"));
-        assertSame(null, OperationEnum.getEnum("Pink"));
-    }
-
-    public void testOperationSerialization() {
-        assertSame(OperationEnum.PLUS, SerializationUtils.clone(OperationEnum.PLUS));
-        assertSame(OperationEnum.MINUS, SerializationUtils.clone(OperationEnum.MINUS));
-    }
-
-    public void testOperationToString() {
-        assertEquals("OperationEnum[Plus]", OperationEnum.PLUS.toString());
-    }
-
-    public void testOperationList() {
-        List list = OperationEnum.getEnumList();
-        assertNotNull(list);
-        assertEquals(2, list.size());
-        assertEquals(list.size(), OperationEnum.getEnumMap().keySet().size());
-
-        Iterator it = list.iterator();
-        assertSame(OperationEnum.PLUS, it.next());
-        assertSame(OperationEnum.MINUS, it.next());
-    }
-
-    public void testOperationMap() {
-        Map map = OperationEnum.getEnumMap();
-        assertNotNull(map);
-        assertEquals(map.keySet().size(), OperationEnum.getEnumList().size());
-
-        assertTrue(map.containsValue(OperationEnum.PLUS));
-        assertTrue(map.containsValue(OperationEnum.MINUS));
-        assertSame(OperationEnum.PLUS, map.get("Plus"));
-        assertSame(OperationEnum.MINUS, map.get("Minus"));
-    }
-
-    public void testOperationCalculation() {
-        assertEquals(3, OperationEnum.PLUS.eval(1, 2));
-        assertEquals(-1, OperationEnum.MINUS.eval(1, 2));
-    }
-
-    // -----------------------------------------------------------------------
-    public void testExtended1Get() {
-        assertSame(Extended1Enum.ALPHA, Extended1Enum.getEnum("Alpha"));
-        assertSame(Extended1Enum.BETA, Extended1Enum.getEnum("Beta"));
-        assertSame(null, Extended1Enum.getEnum("Gamma"));
-        assertSame(null, Extended1Enum.getEnum("Delta"));
-    }
-
-    public void testExtended2Get() {
-        assertSame(Extended1Enum.ALPHA, Extended2Enum.ALPHA);
-        assertSame(Extended1Enum.BETA, Extended2Enum.BETA);
-
-        assertSame(Extended2Enum.ALPHA, Extended2Enum.getEnum("Alpha"));
-        assertSame(Extended2Enum.BETA, Extended2Enum.getEnum("Beta"));
-        assertSame(Extended2Enum.GAMMA, Extended2Enum.getEnum("Gamma"));
-        assertSame(null, Extended2Enum.getEnum("Delta"));
-    }
-
-    public void testExtended3Get() {
-        assertSame(Extended2Enum.ALPHA, Extended3Enum.ALPHA);
-        assertSame(Extended2Enum.BETA, Extended3Enum.BETA);
-        assertSame(Extended2Enum.GAMMA, Extended3Enum.GAMMA);
-
-        assertSame(Extended3Enum.ALPHA, Extended3Enum.getEnum("Alpha"));
-        assertSame(Extended3Enum.BETA, Extended3Enum.getEnum("Beta"));
-        assertSame(Extended3Enum.GAMMA, Extended3Enum.getEnum("Gamma"));
-        assertSame(Extended3Enum.DELTA, Extended3Enum.getEnum("Delta"));
-    }
-
-    public void testExtendedSerialization() {
-        assertSame(Extended1Enum.ALPHA, SerializationUtils.clone(Extended1Enum.ALPHA));
-        assertSame(Extended1Enum.BETA, SerializationUtils.clone(Extended1Enum.BETA));
-        assertSame(Extended2Enum.GAMMA, SerializationUtils.clone(Extended2Enum.GAMMA));
-        assertSame(Extended3Enum.DELTA, SerializationUtils.clone(Extended3Enum.DELTA));
-    }
-
-    public void testExtendedToString() {
-        assertEquals("Extended1Enum[Alpha]", Extended1Enum.ALPHA.toString());
-        assertEquals("Extended1Enum[Beta]", Extended1Enum.BETA.toString());
-
-        assertEquals("Extended1Enum[Alpha]", Extended2Enum.ALPHA.toString());
-        assertEquals("Extended1Enum[Beta]", Extended2Enum.BETA.toString());
-        assertEquals("Extended2Enum[Gamma]", Extended2Enum.GAMMA.toString());
-
-        assertEquals("Extended1Enum[Alpha]", Extended3Enum.ALPHA.toString());
-        assertEquals("Extended1Enum[Beta]", Extended3Enum.BETA.toString());
-        assertEquals("Extended2Enum[Gamma]", Extended3Enum.GAMMA.toString());
-        assertEquals("Extended3Enum[Delta]", Extended3Enum.DELTA.toString());
-    }
-
-    public void testExtended1List() {
-        List list = Extended1Enum.getEnumList();
-        assertNotNull(list);
-        assertEquals(2, list.size());
-        assertEquals(list.size(), Extended1Enum.getEnumMap().keySet().size());
-
-        Iterator it = list.iterator();
-        assertSame(Extended1Enum.ALPHA, it.next());
-        assertSame(Extended1Enum.BETA, it.next());
-    }
-
-    public void testExtended2List() {
-        List list = Extended2Enum.getEnumList();
-        assertNotNull(list);
-        assertEquals(3, list.size());
-        assertEquals(list.size(), Extended2Enum.getEnumMap().keySet().size());
-
-        Iterator it = list.iterator();
-        assertSame(Extended2Enum.ALPHA, it.next());
-        assertSame(Extended2Enum.BETA, it.next());
-        assertSame(Extended2Enum.GAMMA, it.next());
-    }
-
-    public void testExtended3List() {
-        List list = Extended3Enum.getEnumList();
-        assertNotNull(list);
-        assertEquals(4, list.size());
-        assertEquals(list.size(), Extended3Enum.getEnumMap().keySet().size());
-
-        Iterator it = list.iterator();
-        assertSame(Extended3Enum.ALPHA, it.next());
-        assertSame(Extended3Enum.BETA, it.next());
-        assertSame(Extended3Enum.GAMMA, it.next());
-        assertSame(Extended3Enum.DELTA, it.next());
-    }
-
-    public void testExtended1Map() {
-        Map map = Extended1Enum.getEnumMap();
-        assertNotNull(map);
-        assertEquals(map.keySet().size(), Extended1Enum.getEnumList().size());
-
-        assertTrue(map.containsValue(Extended1Enum.ALPHA));
-        assertTrue(map.containsValue(Extended1Enum.BETA));
-        assertSame(Extended1Enum.ALPHA, map.get("Alpha"));
-        assertSame(Extended1Enum.BETA, map.get("Beta"));
-    }
-
-    public void testExtended2Map() {
-        Map map = Extended2Enum.getEnumMap();
-        assertNotNull(map);
-        assertEquals(map.keySet().size(), Extended2Enum.getEnumList().size());
-
-        assertTrue(map.containsValue(Extended2Enum.ALPHA));
-        assertTrue(map.containsValue(Extended2Enum.BETA));
-        assertTrue(map.containsValue(Extended2Enum.GAMMA));
-        assertSame(Extended2Enum.ALPHA, map.get("Alpha"));
-        assertSame(Extended2Enum.BETA, map.get("Beta"));
-        assertSame(Extended2Enum.GAMMA, map.get("Gamma"));
-    }
-
-    public void testExtended3Map() {
-        Map map = Extended3Enum.getEnumMap();
-        assertNotNull(map);
-        assertEquals(map.keySet().size(), Extended3Enum.getEnumList().size());
-
-        assertTrue(map.containsValue(Extended3Enum.ALPHA));
-        assertTrue(map.containsValue(Extended3Enum.BETA));
-        assertTrue(map.containsValue(Extended3Enum.GAMMA));
-        assertTrue(map.containsValue(Extended3Enum.DELTA));
-        assertSame(Extended3Enum.ALPHA, map.get("Alpha"));
-        assertSame(Extended3Enum.BETA, map.get("Beta"));
-        assertSame(Extended3Enum.GAMMA, map.get("Gamma"));
-        assertSame(Extended3Enum.DELTA, map.get("Delta"));
-    }
-
-    // -----------------------------------------------------------------------
-    public void testNested() {
-        List list = new ArrayList(Nest.ColorEnum.getEnumList());
-        assertEquals(3, list.size()); // all is well
-        Iterator it = list.iterator();
-        assertSame(Nest.ColorEnum.RED, it.next());
-        assertSame(Nest.ColorEnum.GREEN, it.next());
-        assertSame(Nest.ColorEnum.BLUE, it.next());
-        // This nesting works because the enum constants are defined in the SAME
-        // class as the getEnumList(). It just acts as a normal enum.
-    }
-
-    public void testNestedBroken() {
-        List list = new ArrayList(NestBroken.ColorEnum.getEnumList());
-        try {
-            assertEquals(0, list.size()); // no enums!!!
-            // this is BROKEN because the enum constants are defined in a DIFFERENT
-            // class from getEnumList(). Once NestBroken class is referenced,
-            // and thus class loaded with its enum constants, the getEnumList works:
-        } catch (AssertionFailedError ex) {
-            // this actually works and isn't broken on Linux SunJDK1.4.1, so...
-            assertEquals(3, list.size());
-        }
-        new NestBroken();
-        list = new ArrayList(NestBroken.ColorEnum.getEnumList());
-        assertEquals(3, list.size()); // all is well!!!
-        Iterator it = list.iterator();
-        assertSame(NestBroken.RED, it.next());
-        assertSame(NestBroken.GREEN, it.next());
-        assertSame(NestBroken.BLUE, it.next());
-    }
-
-    public void testNestedLinked() {
-        List list = new ArrayList(NestLinked.ColorEnum.getEnumList());
-        assertEquals(3, list.size()); // all is well
-        Iterator it = list.iterator();
-        assertSame(NestLinked.RED, it.next());
-        assertSame(NestLinked.GREEN, it.next());
-        assertSame(NestLinked.BLUE, it.next());
-        // This nesting works because a static block in the enum class forces a
-        // class load of the outer class which defines the enum constants.
-    }
-
-    public void testNestedReferenced() {
-        List list = new ArrayList(NestReferenced.ColorEnum.getEnumList());
-        assertEquals(3, list.size()); // all is well
-        Iterator it = list.iterator();
-        assertSame(NestReferenced.RED, it.next());
-        assertSame(NestReferenced.GREEN, it.next());
-        assertSame(NestReferenced.BLUE, it.next());
-        // This nesting works because the enum constants are actually defined in
-        // the SAME class as the getEnumList(). The references in the outer class
-        // are just extra references.
-    }
-
-    public void testColorEnumEqualsWithDifferentClassLoaders() throws SecurityException, IllegalArgumentException,
-            ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException {
-        this.testWithDifferentClassLoaders(ColorEnum.BLUE);
-        this.testWithDifferentClassLoaders(ColorEnum.GREEN);
-        this.testWithDifferentClassLoaders(ColorEnum.RED);
-    }
-
-    void testWithDifferentClassLoaders(ColorEnum colorEnum) throws ClassNotFoundException, SecurityException,
-            NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
-        // Sanity checks:
-        assertTrue(colorEnum.equals(colorEnum));
-        assertNotNull(ColorEnum.class.getClassLoader());
-        // set up:
-        ClassLoader myClassLoader = EnumTest.class.getClassLoader();
-        if (!(myClassLoader instanceof URLClassLoader)) {
-            fail("EnumTest ClassLoader = " + (myClassLoader == null ? null : myClassLoader.getClass().getName()));
-        }
-        ClassLoader classLoader = URLClassLoader.newInstance( ((URLClassLoader)myClassLoader).getURLs(), null);
-        Object enumObjectFromOtherClassLoader = this.getColorEnum(classLoader, colorEnum.getName());
-
-        // the real test, part 1.
-        try {
-            ColorEnum testCase = (ColorEnum) enumObjectFromOtherClassLoader;
-            fail("Should have thrown a ClassCastException for " + testCase);
-        } catch (ClassCastException e) {
-            // normal.
-        }
-
-        // the real test, part 2.
-        assertEquals("The two objects should match even though they are from different class loaders", colorEnum,
-                enumObjectFromOtherClassLoader);
-
-        // the real test, part 3 - testing equals(Object)
-        int falseCount = 0;
-        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {
-            ColorEnum element = (ColorEnum) iter.next();
-            if (!colorEnum.equals(element)) {
-                falseCount++;
-                assertFalse(enumObjectFromOtherClassLoader.equals(element));
-            }
-        }
-        assertEquals(ColorEnum.getEnumList().size() - 1, falseCount);
-
-        // the real test, part 4 - testing compareTo(Object) == 0
-        falseCount = 0;
-        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {
-            ColorEnum element = (ColorEnum) iter.next();
-            if (!colorEnum.equals(element)) {
-                falseCount++;
-                assertFalse( ((Comparable)enumObjectFromOtherClassLoader).compareTo(element) == 0);
-            }
-        }
-        assertEquals(ColorEnum.getEnumList().size() - 1, falseCount);
-    }
-
-    Object getColorEnum(ClassLoader classLoader, String color) throws ClassNotFoundException, SecurityException,
-            NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
-        // Sanity check:
-        ColorEnum.RED.equals(ColorEnum.RED);
-        assertNotNull(ColorEnum.class.getClassLoader());
-        // set up:
-        assertNotNull(classLoader);
-        assertFalse(classLoader.equals(ColorEnum.class.getClassLoader()));
-        Class otherColorEnumClass = null;
-        try {
-            otherColorEnumClass = classLoader.loadClass(ENUM_CLASS_NAME);
-        } catch (ClassNotFoundException e) {
-            // Dump some information to help debug class loader issues under different JREs, Ant, Eclipse.
-            System.err.println("Could not load " + ENUM_CLASS_NAME + " from the class loader " + classLoader);
-            URLClassLoader urlCl = (URLClassLoader) classLoader;
-            URL[] urls = urlCl.getURLs();
-            System.err.println("Class loader has " + urls.length + " URLs:");
-            for (int i = 0; i < urls.length; i++) {
-                System.err.println("URL[" + i + "] = " + urls[i]);
-            }
-            e.printStackTrace();
-            throw e;
-        }
-        assertNotNull(otherColorEnumClass);
-        assertNotNull(otherColorEnumClass.getClassLoader());
-        assertTrue(classLoader.equals(otherColorEnumClass.getClassLoader()));
-        assertFalse(otherColorEnumClass.getClassLoader().equals(ColorEnum.class.getClassLoader()));
-        Method method = otherColorEnumClass.getMethod("getEnum", new Class[]{String.class});
-        Object enumObject = method.invoke(otherColorEnumClass, new Object[]{color});
-        assertNotNull(enumObject);
-        assertFalse(ColorEnum.class.equals(enumObject.getClass()));
-        assertFalse(ColorEnum.class == enumObject.getClass());
-        return enumObject;
-    }
-
-    public void testEqualsToWrongInstance() {
-        for (Iterator iter = ColorEnum.iterator(); iter.hasNext();) {
-            ColorEnum element = (ColorEnum) iter.next();
-            this.testEqualsToWrongInstance(element);
-        }
-    }
-
-    void testEqualsToWrongInstance(ColorEnum colorEnum) {
-        assertEquals(false, colorEnum.equals("test"));
-        assertEquals(false, colorEnum.equals(new Integer(1)));
-        assertEquals(false, colorEnum.equals(new Boolean(true)));
-        assertEquals(false, colorEnum.equals(new StringBuffer("test")));
-        assertEquals(false, colorEnum.equals(new Object()));
-        assertEquals(false, colorEnum.equals(null));
-        assertEquals(false, colorEnum.equals(""));
-        assertEquals(false, colorEnum.equals(ColorEnum.getEnum(null)));
-        assertEquals(false, colorEnum.equals(ColorEnum.getEnum("")));
-        assertEquals(false, colorEnum.equals(ColorEnum.getEnum("This ColorEnum does not exist.")));
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/EnumTestSuite.java b/src/test/org/apache/commons/lang/enum/EnumTestSuite.java
deleted file mode 100644
index 34dde67d..00000000
--- a/src/test/org/apache/commons/lang/enum/EnumTestSuite.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import junit.framework.Test;
-import junit.framework.TestCase;
-import junit.framework.TestSuite;
-import junit.textui.TestRunner;
-
-/**
- * Test suite for the Enum package.
- *
- * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a>
- * @version $Id$
- */
-public class EnumTestSuite extends TestCase {
-    
-    /**
-     * Construct a new instance.
-     */
-    public EnumTestSuite(String name) {
-        super(name);
-    }
-
-    /**
-     * Command-line interface.
-     */
-    public static void main(String[] args) {
-        TestRunner.run(suite());
-    }
-
-    /**
-     * Get the suite of tests
-     */
-    public static Test suite() {
-        TestSuite suite = new TestSuite();
-        suite.setName("Commons-Lang-Enum Tests");
-        suite.addTest(EnumTest.suite());
-        suite.addTest(EnumUtilsTest.suite());
-        suite.addTest(ValuedEnumTest.suite());
-        return suite;
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/EnumUtilsTest.java b/src/test/org/apache/commons/lang/enum/EnumUtilsTest.java
deleted file mode 100644
index 2a180480..00000000
--- a/src/test/org/apache/commons/lang/enum/EnumUtilsTest.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Modifier;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import junit.framework.Test;
-import junit.framework.TestCase;
-import junit.framework.TestSuite;
-
-/**
- * Test cases for the {@link Enum} class.
- *
- * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a>
- * @version $Id$
- */
-
-public final class EnumUtilsTest extends TestCase {
-
-    public EnumUtilsTest(String name) {
-        super(name);
-    }
-
-    public void setUp() {
-    }
-
-    public static Test suite() {
-        TestSuite suite = new TestSuite(EnumUtilsTest.class);
-        suite.setName("EnumUtils Tests");
-        return suite;
-    }
-
-    //-----------------------------------------------------------------------
-    public void testConstructor() {
-        assertNotNull(new EnumUtils());
-        Constructor[] cons = EnumUtils.class.getDeclaredConstructors();
-        assertEquals(1, cons.length);
-        assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));
-        assertEquals(true, Modifier.isPublic(EnumUtils.class.getModifiers()));
-        assertEquals(false, Modifier.isFinal(EnumUtils.class.getModifiers()));
-    }
-    
-    //-----------------------------------------------------------------------
-    public void testIterator() {
-        Iterator it = EnumUtils.iterator(ColorEnum.class);
-        assertSame(ColorEnum.RED, it.next());
-        assertSame(ColorEnum.GREEN, it.next());
-        assertSame(ColorEnum.BLUE, it.next());
-        it = EnumUtils.iterator(DummyEnum.class);
-        assertEquals(false, it.hasNext());
-    }
-
-    public void testIteratorEx() {
-        try {
-            EnumUtils.iterator(null);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            EnumUtils.iterator(Object.class);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    //-----------------------------------------------------------------------
-    public void testList() {
-        List list = EnumUtils.getEnumList(ColorEnum.class);
-        Iterator it = list.iterator();
-        assertSame(ColorEnum.RED, it.next());
-        assertSame(ColorEnum.GREEN, it.next());
-        assertSame(ColorEnum.BLUE, it.next());
-        list = EnumUtils.getEnumList(DummyEnum.class);
-        assertEquals(0, list.size());
-    }
-
-    public void testListEx() {
-        try {
-            EnumUtils.getEnumList(null);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            EnumUtils.getEnumList(Object.class);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    //-----------------------------------------------------------------------
-    public void testMap() {
-        Map map = EnumUtils.getEnumMap(ColorEnum.class);
-        assertTrue(map.containsValue(ColorEnum.RED));
-        assertTrue(map.containsValue(ColorEnum.GREEN));
-        assertTrue(map.containsValue(ColorEnum.BLUE));
-        assertSame(ColorEnum.RED, map.get("Red"));
-        assertSame(ColorEnum.GREEN, map.get("Green"));
-        assertSame(ColorEnum.BLUE, map.get("Blue"));
-        map = EnumUtils.getEnumMap(DummyEnum.class);
-        assertEquals(0, map.size());
-    }
-
-    public void testMapEx() {
-        try {
-            EnumUtils.getEnumMap(null);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            EnumUtils.getEnumMap(Object.class);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    //-----------------------------------------------------------------------
-    public void testGet() {
-        assertSame(ColorEnum.RED, EnumUtils.getEnum(ColorEnum.class, "Red"));
-        assertSame(ColorEnum.GREEN, EnumUtils.getEnum(ColorEnum.class, "Green"));
-        assertSame(ColorEnum.BLUE, EnumUtils.getEnum(ColorEnum.class, "Blue"));
-        assertSame(null, EnumUtils.getEnum(ColorEnum.class, "Pink"));
-        assertSame(null, EnumUtils.getEnum(DummyEnum.class, "Pink"));
-    }
-
-    public void testGetEx() {
-        try {
-            EnumUtils.getEnum(null, "");
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            EnumUtils.getEnum(Object.class, "Red");
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-    //-----------------------------------------------------------------------
-    public void testGetValue() {
-        assertSame(ValuedColorEnum.RED, EnumUtils.getEnum(ValuedColorEnum.class, 1));
-        assertSame(ValuedColorEnum.GREEN, EnumUtils.getEnum(ValuedColorEnum.class, 2));
-        assertSame(ValuedColorEnum.BLUE, EnumUtils.getEnum(ValuedColorEnum.class, 3));
-        assertSame(null, EnumUtils.getEnum(ValuedColorEnum.class, 4));
-        assertSame(null, EnumUtils.getEnum(DummyEnum.class, 5));
-    }
-
-    public void testGetValueEx() {
-        try {
-            EnumUtils.getEnum(null, 0);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-        try {
-            EnumUtils.getEnum(Object.class, 2);
-            fail();
-        } catch (IllegalArgumentException ex) {}
-    }
-
-}
diff --git a/src/test/org/apache/commons/lang/enum/Extended1Enum.java b/src/test/org/apache/commons/lang/enum/Extended1Enum.java
deleted file mode 100644
index 50c303f6..00000000
--- a/src/test/org/apache/commons/lang/enum/Extended1Enum.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Base extended enumeration.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-public class Extended1Enum extends Enum {
-    public static final Extended1Enum ALPHA = new Extended1Enum("Alpha");
-    public static final Extended1Enum BETA = new Extended1Enum("Beta");
-
-    protected Extended1Enum(String name) {
-        super(name);
-    }
-
-    public static Extended1Enum getEnum(String name) {
-        return (Extended1Enum) getEnum(Extended1Enum.class, name);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(Extended1Enum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(Extended1Enum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(Extended1Enum.class);
-    }
-
-}
diff --git a/src/test/org/apache/commons/lang/enum/Extended2Enum.java b/src/test/org/apache/commons/lang/enum/Extended2Enum.java
deleted file mode 100644
index 6f0be124..00000000
--- a/src/test/org/apache/commons/lang/enum/Extended2Enum.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Extended enumeration.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-public class Extended2Enum extends Extended1Enum {
-    public static final Extended1Enum GAMMA = new Extended2Enum("Gamma");
-
-    protected Extended2Enum(String color) {
-        super(color);
-    }
-
-    public static Extended1Enum getEnum(String name) {
-        return (Extended1Enum) getEnum(Extended2Enum.class, name);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(Extended2Enum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(Extended2Enum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(Extended2Enum.class);
-    }
-
-}
diff --git a/src/test/org/apache/commons/lang/enum/Extended3Enum.java b/src/test/org/apache/commons/lang/enum/Extended3Enum.java
deleted file mode 100644
index c8574102..00000000
--- a/src/test/org/apache/commons/lang/enum/Extended3Enum.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Extended enumeration.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-public class Extended3Enum extends Extended2Enum {
-    public static final Extended1Enum DELTA = new Extended3Enum("Delta");
-
-    protected Extended3Enum(String name) {
-        super(name);
-    }
-
-    public static Extended1Enum getEnum(String name) {
-        return (Extended1Enum) Enum.getEnum(Extended3Enum.class, name);
-    }
-
-    public static Map getEnumMap() {
-        return Enum.getEnumMap(Extended3Enum.class);
-    }
-
-    public static List getEnumList() {
-        return Enum.getEnumList(Extended3Enum.class);
-    }
-
-    public static Iterator iterator() {
-        return Enum.iterator(Extended3Enum.class);
-    }
-
-}
diff --git a/src/test/org/apache/commons/lang/enum/Nest.java b/src/test/org/apache/commons/lang/enum/Nest.java
deleted file mode 100644
index d31ef328..00000000
--- a/src/test/org/apache/commons/lang/enum/Nest.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Color enumeration demonstrating a normal simple nesting case.
- * All is well here as the nested enum class is really no different
- * to any other class.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-
-public final class Nest {
-    
-    public Nest() {
-        super();
-    }
-    
-    public static final class ColorEnum extends Enum {
-        public static final ColorEnum RED = new ColorEnum("Red");
-        public static final ColorEnum GREEN = new ColorEnum("Green");
-        public static final ColorEnum BLUE = new ColorEnum("Blue");
-
-        private ColorEnum(String color) {
-            super(color);
-        }
-
-        public static ColorEnum getEnum(String color) {
-            return (ColorEnum) getEnum(ColorEnum.class, color);
-        }
-
-        public static Map getEnumMap() {
-            return getEnumMap(ColorEnum.class);
-        }
-
-        public static List getEnumList() {
-            return getEnumList(ColorEnum.class);
-        }
-
-        public static Iterator iterator() {
-            return iterator(ColorEnum.class);
-        }
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/NestBroken.java b/src/test/org/apache/commons/lang/enum/NestBroken.java
deleted file mode 100644
index 8f6e9194..00000000
--- a/src/test/org/apache/commons/lang/enum/NestBroken.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Color enumeration which demonstrates how to break the enum system.
- * <p>
- * The class loader sees the two classes here as independent - the enum
- * class is nested, not an inner class. Calling getEnumList() on ColorEnum
- * will return an empty list, unless and until the NestBroken class is
- * referenced.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-
-public final class NestBroken {
-    
-    public static final ColorEnum RED = new ColorEnum("Red");
-    public static final ColorEnum GREEN = new ColorEnum("Green");
-    public static final ColorEnum BLUE = new ColorEnum("Blue");
-    
-    public NestBroken() {
-        super();
-    }
-    
-    public static final class ColorEnum extends Enum {
-
-        private ColorEnum(String color) {
-            super(color);
-        }
-
-        public static ColorEnum getEnum(String color) {
-            return (ColorEnum) getEnum(ColorEnum.class, color);
-        }
-
-        public static Map getEnumMap() {
-            return getEnumMap(ColorEnum.class);
-        }
-
-        public static List getEnumList() {
-            return getEnumList(ColorEnum.class);
-        }
-
-        public static Iterator iterator() {
-            return iterator(ColorEnum.class);
-        }
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/NestLinked.java b/src/test/org/apache/commons/lang/enum/NestLinked.java
deleted file mode 100644
index 499b4a68..00000000
--- a/src/test/org/apache/commons/lang/enum/NestLinked.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Color enumeration which demonstrates how to define the constants in a
- * different class to the Enum. The extra <code>static{}</code> block is
- * needed to ensure that the enum constants are created before the
- * static methods on the ColorEnum are used.
- * <p>
- * The class loader sees the two classes here as independent - the enum
- * class is nested, not an inner class. The static block thus forces the
- * class load of the outer class, which is needed to initialise the enums.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-
-public final class NestLinked {
-    
-    public static final ColorEnum RED = new ColorEnum("Red");
-    public static final ColorEnum GREEN = new ColorEnum("Green");
-    public static final ColorEnum BLUE = new ColorEnum("Blue");
-    
-    public NestLinked() {
-        super();
-    }
-    
-    public static final class ColorEnum extends Enum {
-
-        static {
-            // Explicitly reference the class where the enums are defined
-            Object obj = NestLinked.RED;
-        }
-        
-        private ColorEnum(String color) {
-            super(color);
-        }
-
-        public static ColorEnum getEnum(String color) {
-            return (ColorEnum) getEnum(ColorEnum.class, color);
-        }
-
-        public static Map getEnumMap() {
-            return getEnumMap(ColorEnum.class);
-        }
-
-        public static List getEnumList() {
-            return getEnumList(ColorEnum.class);
-        }
-
-        public static Iterator iterator() {
-            return iterator(ColorEnum.class);
-        }
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/NestReferenced.java b/src/test/org/apache/commons/lang/enum/NestReferenced.java
deleted file mode 100644
index dbbef4f7..00000000
--- a/src/test/org/apache/commons/lang/enum/NestReferenced.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Color enumeration which demonstrates how to provide a view of the constants
- * in a different class to the Enum. This technique is the safest, however it
- * is obviously inconvenient as it involves defining two sets of constants.
- * See NestedLinked for an alternative.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-
-public final class NestReferenced {
-    
-    public static final ColorEnum RED = ColorEnum.RED;
-    public static final ColorEnum GREEN = ColorEnum.GREEN;
-    public static final ColorEnum BLUE = ColorEnum.BLUE;
-    
-    public NestReferenced() {
-        super();
-    }
-    
-    public static final class ColorEnum extends Enum {
-
-        // must be defined here, not just in outer class
-        private static final ColorEnum RED = new ColorEnum("Red");
-        private static final ColorEnum GREEN = new ColorEnum("Green");
-        private static final ColorEnum BLUE = new ColorEnum("Blue");
-        
-        private ColorEnum(String color) {
-            super(color);
-        }
-
-        public static ColorEnum getEnum(String color) {
-            return (ColorEnum) getEnum(ColorEnum.class, color);
-        }
-
-        public static Map getEnumMap() {
-            return getEnumMap(ColorEnum.class);
-        }
-
-        public static List getEnumList() {
-            return getEnumList(ColorEnum.class);
-        }
-
-        public static Iterator iterator() {
-            return iterator(ColorEnum.class);
-        }
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/OperationEnum.java b/src/test/org/apache/commons/lang/enum/OperationEnum.java
deleted file mode 100644
index 0cbae392..00000000
--- a/src/test/org/apache/commons/lang/enum/OperationEnum.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Operator enumeration.
- *
- * @author Stephen Colebourne
- * @version $Id$
- */
-public abstract class OperationEnum extends Enum {
-    // This syntax works for JDK 1.3 and upwards:
-//    public static final OperationEnum PLUS = new OperationEnum("Plus") {
-//        public int eval(int a, int b) {
-//            return (a + b);
-//        }
-//    };
-//    public static final OperationEnum MINUS = new OperationEnum("Minus") {
-//        public int eval(int a, int b) {
-//            return (a - b);
-//        }
-//    };
-    // This syntax works for JDK 1.2 and upwards:
-    public static final OperationEnum PLUS = new PlusOperation();
-    private static class PlusOperation extends OperationEnum {
-        private PlusOperation() {
-            super("Plus");
-        }
-        public int eval(int a, int b) {
-            return (a + b);
-        }
-    }
-    public static final OperationEnum MINUS = new MinusOperation();
-    private static class MinusOperation extends OperationEnum {
-        private MinusOperation() {
-            super("Minus");
-        }
-        public int eval(int a, int b) {
-            return (a - b);
-        }
-    }
-
-    private OperationEnum(String name) {
-        super(name);
-    }
-    
-    public final Class getEnumClass() {
-        return OperationEnum.class;
-    }
-
-    public abstract int eval(int a, int b);
-
-    public static OperationEnum getEnum(String name) {
-        return (OperationEnum) getEnum(OperationEnum.class, name);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(OperationEnum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(OperationEnum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(OperationEnum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/ValuedColorEnum.java b/src/test/org/apache/commons/lang/enum/ValuedColorEnum.java
deleted file mode 100644
index 5181cd76..00000000
--- a/src/test/org/apache/commons/lang/enum/ValuedColorEnum.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Color enumeration.
- *
- * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a>
- * @version $Id$
- */
-
-public final class ValuedColorEnum extends ValuedEnum {
-    public static final ValuedColorEnum RED = new ValuedColorEnum("Red", 1);
-    public static final ValuedColorEnum GREEN = new ValuedColorEnum("Green", 2);
-    public static final ValuedColorEnum BLUE = new ValuedColorEnum("Blue", 3);
-
-    private ValuedColorEnum(String color, int value) {
-        super(color, value);
-    }
-
-    public static ValuedColorEnum getEnum(String color) {
-        return (ValuedColorEnum) getEnum(ValuedColorEnum.class, color);
-    }
-
-    public static ValuedColorEnum getEnum(int value) {
-        return (ValuedColorEnum) getEnum(ValuedColorEnum.class, value);
-    }
-
-    public static Map getEnumMap() {
-        return getEnumMap(ValuedColorEnum.class);
-    }
-
-    public static List getEnumList() {
-        return getEnumList(ValuedColorEnum.class);
-    }
-
-    public static Iterator iterator() {
-        return iterator(ValuedColorEnum.class);
-    }
-}
diff --git a/src/test/org/apache/commons/lang/enum/ValuedEnumTest.java b/src/test/org/apache/commons/lang/enum/ValuedEnumTest.java
deleted file mode 100644
index 042647d1..00000000
--- a/src/test/org/apache/commons/lang/enum/ValuedEnumTest.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.lang.enum;
-
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import junit.framework.Test;
-import junit.framework.TestCase;
-import junit.framework.TestSuite;
-
-import org.apache.commons.lang.SerializationUtils;
-
-/**
- * Test cases for the {@link Enum} class.
- *
- * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a>
- * @version $Id$
- */
-
-public final class ValuedEnumTest extends TestCase {
-
-    public ValuedEnumTest(String name) {
-        super(name);
-    }
-
-    public void setUp() {
-    }
-
-    public static Test suite() {
-        TestSuite suite = new TestSuite(ValuedEnumTest.class);
-        suite.setName("ValuedEnum Tests");
-        return suite;
-    }
-
-    public void testName() {
-        assertEquals("Red", ValuedColorEnum.RED.getName());
-        assertEquals("Green", ValuedColorEnum.GREEN.getName());
-        assertEquals("Blue", ValuedColorEnum.BLUE.getName());
-    }
-
-    public void testValue() {
-        assertEquals(1, ValuedColorEnum.RED.getValue());
-        assertEquals(2, ValuedColorEnum.GREEN.getValue());
-        assertEquals(3, ValuedColorEnum.BLUE.getValue());
-    }
-
-    public void testCompareTo() {
-        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.BLUE) == 0);
-        assertTrue(ValuedColorEnum.RED.compareTo(ValuedColorEnum.BLUE) < 0);
-        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.RED) > 0);
-    }
-
-    public void testEquals() {
-        assertSame(ValuedColorEnum.RED, ValuedColorEnum.RED);
-        assertSame(ValuedColorEnum.getEnum("Red"), ValuedColorEnum.RED);
-    }
-
-    public void testToString() {
-        String toString = ValuedColorEnum.RED.toString();
-        assertEquals("ValuedColorEnum[Red=1]", toString);
-        assertSame(toString, ValuedColorEnum.RED.toString());
-    }
-
-    public void testIterator() {
-        Iterator it = ValuedColorEnum.iterator();
-        assertSame(ValuedColorEnum.RED, it.next());
-        assertSame(ValuedColorEnum.GREEN, it.next());
-        assertSame(ValuedColorEnum.BLUE, it.next());
-    }
-
-    public void testList() {
-        List list = ValuedColorEnum.getEnumList();
-        
-        assertNotNull(list);
-        
-        assertEquals( list.size(),
-                     ValuedColorEnum.getEnumMap().keySet().size());
-        
-        Iterator it = list.iterator();
-        assertSame(ValuedColorEnum.RED, it.next());
-        assertSame(ValuedColorEnum.GREEN, it.next());
-        assertSame(ValuedColorEnum.BLUE, it.next());
-    }
-
-    public void testMap() {
-        Map map = ValuedColorEnum.getEnumMap();
-        
-        assertNotNull(map);
-        
-        assertEquals( map.keySet().size(),
-                     ValuedColorEnum.getEnumList().size());
-                     
-        assertTrue(map.containsValue(ValuedColorEnum.RED));
-        assertTrue(map.containsValue(ValuedColorEnum.GREEN));
-        assertTrue(map.containsValue(ValuedColorEnum.BLUE));
-        assertSame(ValuedColorEnum.RED, map.get("Red"));
-        assertSame(ValuedColorEnum.GREEN, map.get("Green"));
-        assertSame(ValuedColorEnum.BLUE, map.get("Blue"));
-    }
-
-    public void testGet() {
-        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum("Red"));
-        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum("Green"));
-        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum("Blue"));
-        assertSame(null, ValuedColorEnum.getEnum("Pink"));
-    }
-
-    public void testGetValue() {
-        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum(1));
-        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum(2));
-        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum(3));
-        assertSame(null, ValuedColorEnum.getEnum(4));
-    }
-
-    public void testSerialization() {
-        assertSame(ValuedColorEnum.RED, SerializationUtils.clone(ValuedColorEnum.RED));
-        assertSame(ValuedColorEnum.GREEN, SerializationUtils.clone(ValuedColorEnum.GREEN));
-        assertSame(ValuedColorEnum.BLUE, SerializationUtils.clone(ValuedColorEnum.BLUE));
-    }
-
-}
